/*
 Navicat Premium Data Transfer

 Source Server         : mysql5.7
 Source Server Type    : MySQL
 Source Server Version : 50725
 Source Host           : localhost:3307
 Source Schema         : feiniao_blog

 Target Server Type    : MySQL
 Target Server Version : 50725
 File Encoding         : 65001

 Date: 25/04/2019 11:35:41
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article`  (
  `article_id` int(11) NOT NULL AUTO_INCREMENT,
  `article_user_id` int(11) UNSIGNED NULL DEFAULT NULL,
  `article_title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `article_content` mediumtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `article_view_count` int(11) NULL DEFAULT 0,
  `article_comment_count` int(11) NULL DEFAULT 0,
  `article_like_count` int(11) NULL DEFAULT 0,
  `article_is_comment` int(1) UNSIGNED NULL DEFAULT NULL,
  `article_status` int(1) UNSIGNED NULL DEFAULT 1,
  `article_order` int(11) UNSIGNED NULL DEFAULT NULL,
  `article_update_time` datetime(0) NULL DEFAULT NULL,
  `article_create_time` datetime(0) NULL DEFAULT NULL,
  PRIMARY KEY (`article_id`) USING BTREE
) ENGINE = MyISAM AUTO_INCREMENT = 48 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES (40, 1, 'Spring Boot学习', '<p>Spring Boot是为了简化Spring应用的创建、运行、调试、部署等而出现的，使用它可以做到专注于Spring应用的开发，而无需过多关注XML的配置。</p><p>简单来说，它提供了一堆依赖打包，并已经按照使用习惯解决了依赖问题---习惯大于约定。</p><p>&nbsp;</p><p>Spring Boot默认使用tomcat作为服务器，使用logback提供日志记录。</p><p>&nbsp;</p><p>无需多言，直接进入节奏：</p><p>&nbsp;</p><p><span>前提</span></p><p>Spring Boot提供了一系列的依赖包，所以需要构建工具的支持：maven 或 gradle。个人仅熟悉maven，所以下面的内容都是maven相关的。</p><p>如果不熟悉maven，请先了解一下。</p><p><span>使用</span></p><p>① 新建一个maven项目。</p><p>② pom中parent设为&nbsp;<em>spring-boot-starter-parent</em>&nbsp;。建议使用最新的<strong>&nbsp;RELEASE</strong>&nbsp;版本。否则可能需要设置&nbsp;<em><span>&lt;repositories/&gt;&nbsp;</span></em><span>和</span><em><span>&lt;pluginRepositories/&gt;</span></em>&nbsp;。</p><p>③ 添加应用需要的starter模块，作为示例，我们仅添加web starter模块。</p><p>　　这里需要解释下starter模块，简单的说，就是一系列的依赖包组合。例如web starter模块，就是包含了Spring Boot预定义的一些Web开发的常用依赖：</p><p>○ spring-web, spring-webmvc&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Spring WebMvc框架</p><p>○ tomcat-embed-*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 内嵌Tomcat容器</p><p>○ jackson&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;处理json数据</p><p>○ spring-*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Spring框架</p><p>○ spring-boot-autoconfigure&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Spring Boot提供的自动配置功能</p><p>　换句话说，当你添加了相应的starter模块，就相当于添加了相应的所有必须的依赖包。</p><p>　　starter模块的列表及含义，见&nbsp;<span class=\"link_title\"><a href=\"http://blog.csdn.net/chszs/article/details/50610474\">Spring Boot的启动器Starter详解</a>&nbsp;。</span></p><p>&nbsp;</p><p>至此，pom内容如下：</p><div class=\"cnblogs_code\"><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"http://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div><pre><span>&lt;</span><span>project </span><span>xmlns</span><span>=\"http://maven.apache.org/POM/4.0.0\"</span><span> xmlns:xsi</span><span>=\"http://www.w3.org/2001/XMLSchema-instance\"</span><span>\r\n    xsi:schemaLocation</span><span>=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span><span>&gt;</span>\r\n    <span>&lt;</span><span>modelVersion</span><span>&gt;</span>4.0.0<span>&lt;/</span><span>modelVersion</span><span>&gt;</span>\r\n    <span>&lt;</span><span>groupId</span><span>&gt;</span>cn.larry.spring<span>&lt;/</span><span>groupId</span><span>&gt;</span>\r\n    <span>&lt;</span><span>artifactId</span><span>&gt;</span>larry-spring-demo4<span>&lt;/</span><span>artifactId</span><span>&gt;</span>\r\n    <span>&lt;</span><span>version</span><span>&gt;</span>0.0.1-SNAPSHOT<span>&lt;/</span><span>version</span><span>&gt;</span>\r\n\r\n    <span>&lt;</span><span>parent</span><span>&gt;</span>\r\n        <span>&lt;</span><span>groupId</span><span>&gt;</span>org.springframework.boot<span>&lt;/</span><span>groupId</span><span>&gt;</span>\r\n        <span>&lt;</span><span>artifactId</span><span>&gt;</span>spring-boot-starter-parent<span>&lt;/</span><span>artifactId</span><span>&gt;</span>\r\n        <span>&lt;</span><span>version</span><span>&gt;</span>1.4.0.RELEASE<span>&lt;/</span><span>version</span><span>&gt;</span>\r\n    <span>&lt;/</span><span>parent</span><span>&gt;</span>\r\n\r\n    <span>&lt;</span><span>dependencies</span><span>&gt;</span>\r\n        <span>&lt;</span><span>dependency</span><span>&gt;</span>\r\n            <span>&lt;</span><span>groupId</span><span>&gt;</span>org.springframework.boot<span>&lt;/</span><span>groupId</span><span>&gt;</span>\r\n            <span>&lt;</span><span>artifactId</span><span>&gt;</span>spring-boot-starter-web<span>&lt;/</span><span>artifactId</span><span>&gt;</span>\r\n        <span>&lt;/</span><span>dependency</span><span>&gt;</span>\r\n    <span>&lt;/</span><span>dependencies</span><span>&gt;</span>\r\n<span>&lt;/</span><span>project</span><span>&gt;</span></pre><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"http://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div></div><p>保存pom，刷新maven，以便刷新依赖导入。<br>基本上，如果没有特别的需要，现在就可以直接写Controller了！！！--特别的需要 是指设置容器、访问端口、路径等。后面再解释。</p><p>④ 写一个简单的Controller。--直接拿了&nbsp;<a href=\"http://www.tianmaying.com/tutorial/spring-boot-overview\" target=\"_blank\">Spring Boot——开发新一代Spring Java应用</a>&nbsp;中的示例。</p><div class=\"cnblogs_code\"><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"http://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div><pre><span>package</span><span> cn.larry.spring.controller;\r\n\r\n</span><span>import</span><span> org.springframework.boot.SpringApplication;\r\n</span><span>import</span><span> org.springframework.boot.autoconfigure.EnableAutoConfiguration;\r\n</span><span>import</span><span> org.springframework.stereotype.Controller;\r\n</span><span>import</span><span> org.springframework.web.bind.annotation.RequestMapping;\r\n</span><span>import</span><span> org.springframework.web.bind.annotation.ResponseBody;\r\n\r\n@Controller\r\n@EnableAutoConfiguration\r\n</span><span>public</span> <span>class</span><span> SampleController {\r\n\r\n    @RequestMapping(</span>\"/\"<span>)\r\n    @ResponseBody\r\n    String home() {\r\n        </span><span>return</span> \"Hello World!\"<span>;\r\n    }\r\n\r\n    </span><span>public</span> <span>static</span> <span>void</span> main(String[] args) <span>throws</span><span> Exception {\r\n        SpringApplication.run(SampleController.</span><span>class</span><span>, args);\r\n    }\r\n}</span></pre><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"http://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div></div><p>这里有两个新东西：<em>@EnableAutoConfiguration</em>&nbsp;和&nbsp;<em>SpringApplication</em>&nbsp;。</p><p><em>@EnableAutoConfiguration</em>&nbsp;用于自动配置。简单的说，它会根据你的pom配置（实际上应该是根据具体的依赖）来判断这是一个什么应用，并创建相应的环境。</p><p>在上面这个例子中，<em>@EnableAutoConfiguration</em>&nbsp;会判断出这是一个web应用，所以会创建相应的web环境。</p><p>&nbsp;</p><p><em>SpringApplication</em>&nbsp;则是用于从main方法启动Spring应用的类。默认，它会执行以下<span>步骤</span>：</p><ol><li>创建一个合适的ApplicationContext实例 （取决于classpath）。</li><li>注册一个CommandLinePropertySource，以便将命令行参数作为Spring properties。</li><li>刷新application context，加载所有单例beans。</li><li>激活所有CommandLineRunner beans。</li></ol><p>默认，直接使用<em>SpringApplication</em>&nbsp;的静态方法run()即可。但也可以创建实例，并自行配置需要的设置。</p><p>具体的描述见javadoc即可，如下：</p><div class=\"cnblogs_code\"><img id=\"code_img_closed_d3e4a126-5ef4-4aff-b88f-6d3c1ed925c4\" class=\"code_img_closed\" src=\"https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif\" alt=\"\">&nbsp;<span class=\"cnblogs_code_collapse\">View Code</span></div><p>&nbsp;</p><p>⑤ 现在，直接右键启动main方法即可。启动信息（包括关闭信息）如下：</p><p>.&nbsp; &nbsp;____&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; __ _ _</p><p>&nbsp;/\\\\ / ___\'_ __ _ _(_)_ __&nbsp; __ _ \\ \\ \\ \\</p><p>( ( )\\___ | \'_ | \'_| | \'_ \\/ _` | \\ \\ \\ \\</p><p>&nbsp;\\\\/&nbsp; ___)| |_)| | | | | || (_| |&nbsp; ) ) ) )</p><p>&nbsp; \'&nbsp; |____| .__|_| |_|_| |_\\__, | / / / /</p><p>&nbsp;=========|_|==============|___/=/_/_/_/</p><p>&nbsp;:: Spring Boot ::&nbsp; &nbsp; &nbsp; &nbsp; (v1.4.0.RELEASE)</p><p><br></p><p>2016-08-15 14:30:16.565&nbsp; INFO 10652 --- [&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;main] c.l.spring.controller.SampleController&nbsp; &nbsp;: Starting SampleController on Larry with PID 10652 (D:\\Workspace\\Workspace_sts\\larry-spring-demo4\\target\\classes started by Administrator in D:\\Workspace\\Workspace_sts\\larry-spring-demo4)</p><p>2016-08-15 14:30:16.567&nbsp; INFO 10652 --- [&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;main] c.l.spring.controller.SampleController&nbsp; &nbsp;: No active profile set, falling back to default profiles: default</p><p>2016-08-15 14:30:16.596&nbsp; INFO 10652 --- [&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;main] ationConfigEmbeddedWebApplicationContext : Refreshing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@4a94ee4: startup date [Mon Aug 15 14:30:16 CST 2016]; root of context hierarchy</p><p>2016-08-15 14:30:17.676&nbsp; INFO 10652 --- [&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat initialized with port(s): 8080 (http)</p><p>2016-08-15 14:30:17.687&nbsp; INFO 10652 --- [&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;main] o.apache.catalina.core.StandardService&nbsp; &nbsp;: Starting service Tomcat</p><p>2016-08-15 14:30:17.688&nbsp; INFO 10652 --- [&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;main] org.apache.catalina.core.StandardEngine&nbsp; : Starting Servlet Engine: Apache Tomcat/8.5.4</p><p>2016-08-15 14:30:17.767&nbsp; INFO 10652 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]&nbsp; &nbsp; &nbsp; &nbsp;: Initializing Spring embedded WebApplicationContext</p><p>2016-08-15 14:30:17.767&nbsp; INFO 10652 --- [ost-startStop-1] o.s.web.context.ContextLoader&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : Root WebApplicationContext: initialization completed in 1173 ms</p><p>2016-08-15 14:30:17.928&nbsp; INFO 10652 --- [ost-startStop-1] o.s.b.w.servlet.ServletRegistrationBean&nbsp; : Mapping servlet: \'dispatcherServlet\' to [/]</p><p>2016-08-15 14:30:17.932&nbsp; INFO 10652 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean&nbsp; &nbsp;: Mapping filter: \'characterEncodingFilter\' to: [/*]</p><p>2016-08-15 14:30:17.933&nbsp; INFO 10652 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean&nbsp; &nbsp;: Mapping filter: \'hiddenHttpMethodFilter\' to: [/*]</p><p>2016-08-15 14:30:17.933&nbsp; INFO 10652 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean&nbsp; &nbsp;: Mapping filter: \'httpPutFormContentFilter\' to: [/*]</p><p>2016-08-15 14:30:17.933&nbsp; INFO 10652 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean&nbsp; &nbsp;: Mapping filter: \'requestContextFilter\' to: [/*]</p><p>2016-08-15 14:30:18.177&nbsp; INFO 10652 --- [&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;main] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@4a94ee4: startup date [Mon Aug 15 14:30:16 CST 2016]; root of context hierarchy</p><p>2016-08-15 14:30:18.230&nbsp; INFO 10652 --- [&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped \"{[/]}\" onto java.lang.String cn.larry.spring.controller.SampleController.home()</p><p>2016-08-15 14:30:18.234&nbsp; INFO 10652 --- [&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped \"{[/error]}\" onto public org.springframework.http.ResponseEntity&lt;java.util.Map&lt;java.lang.String, java.lang.Object&gt;&gt; org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)</p><p>2016-08-15 14:30:18.235&nbsp; INFO 10652 --- [&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped \"{[/error],produces=[text/html]}\" onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)</p><p>2016-08-15 14:30:18.262&nbsp; INFO 10652 --- [&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;main] o.s.w.s.handler.SimpleUrlHandlerMapping&nbsp; : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]</p><p>2016-08-15 14:30:18.262&nbsp; INFO 10652 --- [&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;main] o.s.w.s.handler.SimpleUrlHandlerMapping&nbsp; : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]</p><p>2016-08-15 14:30:18.295&nbsp; INFO 10652 --- [&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;main] o.s.w.s.handler.SimpleUrlHandlerMapping&nbsp; : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]</p><p>2016-08-15 14:30:18.423&nbsp; INFO 10652 --- [&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;main] o.s.j.e.a.AnnotationMBeanExporter&nbsp; &nbsp; &nbsp; &nbsp; : Registering beans for JMX exposure on startup</p><p>2016-08-15 14:30:18.480&nbsp; INFO 10652 --- [&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http)</p><p>2016-08-15 14:30:18.485&nbsp; INFO 10652 --- [&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;main] c.l.spring.controller.SampleController&nbsp; &nbsp;: Started SampleController in 2.209 seconds (JVM running for 2.642)</p><p>2016-08-15 14:30:23.564&nbsp; INFO 10652 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]&nbsp; &nbsp; &nbsp; &nbsp;: Initializing Spring FrameworkServlet \'dispatcherServlet\'</p><p>2016-08-15 14:30:23.564&nbsp; INFO 10652 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet&nbsp; &nbsp; &nbsp; &nbsp; : FrameworkServlet \'dispatcherServlet\': initialization started</p><p>2016-08-15 14:30:23.574&nbsp; INFO 10652 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet&nbsp; &nbsp; &nbsp; &nbsp; : FrameworkServlet \'dispatcherServlet\': initialization completed in 10 ms</p><p>2016-08-15 14:30:32.002&nbsp; INFO 10652 --- [2)-192.168.56.1] inMXBeanRegistrar$SpringApplicationAdmin : Application shutdown requested.</p><p>2016-08-15 14:30:32.003&nbsp; INFO 10652 --- [2)-192.168.56.1] ationConfigEmbeddedWebApplicationContext : Closing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@4a94ee4: startup date [Mon Aug 15 14:30:16 CST 2016]; root of context hierarchy</p><p>2016-08-15 14:30:32.004&nbsp; INFO 10652 --- [2)-192.168.56.1] o.s.j.e.a.AnnotationMBeanExporter&nbsp; &nbsp; &nbsp; &nbsp; : Unregistering JMX-exposed beans on shutdown</p><p><span>如果使用sts （Spring Tools Suite--没意外的话，后面的博客我会介绍一下），还可以用Spring Application的形式启动，信息不变，但是彩色的，如下：</span></p><p><img src=\"https://images2015.cnblogs.com/blog/870358/201608/870358-20160815154849281-1666475067.png\"><span>⑥ 根据这个信息，我们可以看出很多东西，不过现在先访问一下吧。</span></p><p>默认访问地址：&nbsp;<a href=\"http://localhost:8080/\" target=\"_blank\"><em>http://localhost:8080/</em></a></p><p>按照之前的web项目习惯，你可能会问，怎么没有项目路径？</p><p>这就是Spring Boot的默认设置了，将项目路径直接设为根路径。</p><p>当然，我们也可以设置自己的项目路径 -- 在classpath下的 application.properties 或者 application.yaml 文件中设置即可。</p><p>内容如下：</p><div class=\"cnblogs_code\"><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"http://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div><pre><span># application.yaml\r\n# Server settings (ServerProperties)\r\nserver:\r\n  port: 8080\r\n  address: 127.0.0.1\r\n  sessionTimeout: 30\r\n  contextPath: /aaa\r\n\r\n  # Tomcat specifics\r\n  tomcat:\r\n    accessLogEnabled: false\r\n    protocolHeader: x-forwarded-proto\r\n    remoteIpHeader: x-forwarded-for\r\n    basedir:\r\n    backgroundProcessorDelay: 30 # secs</span></pre><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"http://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div></div><div class=\"cnblogs_code\"><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"http://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div><pre><span># application.properties<br># Server settings (ServerProperties)<br>server.port=8080<br>server.address=127.0.0.1<br>#server.sessionTimeout=30<br>server.contextPath=/aaa<br><br># Tomcat specifics<br>#server.tomcat.accessLogEnabled=false<br>server.tomcat.protocolHeader=x-forwarded-proto<br>server.tomcat.remoteIpHeader=x-forwarded-for<br>server.tomcat.basedir=<br>server.tomcat.backgroundProcessorDelay=30</span></pre><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"http://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div></div><p>上面，&nbsp;<em>server.contextPath=/aaa</em>&nbsp;就是设置了项目路径。所以现在需要访问&nbsp;<a href=\"http://localhost:8080/aaa/\" target=\"_blank\">http://localhost:8080/aaa/</a>&nbsp;才行。</p><p>&nbsp;</p><p><span>分析</span></p><p>OK，当目前为止，已经成功运行并访问了一个 SpringMVC 应用。简单的不能再简单了！</p><p>再来看一下启动时的信息：</p><div class=\"cnblogs_code\"><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"http://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div><pre><span>第 9 行，启动SampleController。\r\n第10行，查找active profile，无，设为default。\r\n第11行，刷新上下文。\r\n第12行，初始化tomcat，设置端口8080，设置访问方式为http。\r\n第13行，启动tomcat服务。\r\n第14行，启动Servlet引擎。\r\n第15行，Spring内嵌的WebApplicationContext <span>初始化</span>开始。<br>第16行，Spring内嵌的WebApplicationContext 初始化完成。<br>第17行，映射servlet，将 dispatcherServlet 映射到 [/] 。 <br>第18行，映射filter，将 characterEncodingFilter 映射到 [/*] 。 <br>第19行，映射filter，将 hiddenHttpMethodFilter 映射到 [/*] 。 <br>第20行，映射filter，将 httpPutFormContentFilter 映射到 [/*] 。 <br>第21行，映射filter，将 requestContextFilter 映射到 [/*] 。 <br>第22行，查找 @ControllerAdvice。 <br>第23行，映射路径 \"{[/]}\" 到 cn.larry.spring.controller.SampleController.home()。 <br>第24行，映射路径 \"{[/error]}\" 到 org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)。 <br>第25行，映射路径 \"{[/error],produces=[text/html]}\" 到 org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)。 <br>第26行，略。 第27行，略。 第28行，略。 第29行，略。 <br>第30行，tomcat启动完毕。 <br>第31行，SampleController启动耗费的时间。 <br>第32行，初始化 dispatcherServlet 。 <br>第33行，dispatcherServlet 的初始化已启动。 <br>第34行，dispatcherServlet 的初始化已完成。 <br>第35行，收到shutdown关闭请求。 <br>第36行，关闭AnnotationConfigEmbeddedWebApplicationContext。 <br>第37行，略。</span></pre><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"http://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div></div><p>从上面的启动信息中可以明显看到SpringMVC的加载过程，特别需要注意的是这种默认方式下加载的几个 filter 。</p><p>这里就不再介绍了，具体可以见本文末尾最后三个链接。</p><p>&nbsp;</p><h3>2018.1.8 补充</h3><p>使用IDEA的Spring Initializer，也可以新建Spring Boot项目，过程类似，不再赘述了。</p><p>&nbsp;</p><p>参考：</p><address id=\"tutorial-title\"><a href=\"http://www.tianmaying.com/tutorial/spring-boot-overview\" target=\"_blank\">Spring Boot——开发新一代Spring Java应用</a></address><address><span class=\"link_title\"><a href=\"http://blog.csdn.net/chszs/article/details/50610474\">Spring Boot的启动器Starter详解</a></span></address><address><a href=\"http://www.infoq.com/cn/articles/microframeworks1-spring-boot/\" target=\"_blank\">深入学习微框架：Spring Boot</a></address><address>&nbsp;</address><address><span class=\"link_title\"><a href=\"http://blog.csdn.net/geloin/article/details/7444718\">Spring MVC过滤器-RequestContextFilter</a></span></address><address><span class=\"link_title\"><a href=\"http://blog.csdn.net/geloin/article/details/7444590\">Spring MVC过滤器-HttpPutFormContentFilter</a></span></address><address><span class=\"link_title\"><a href=\"http://blog.csdn.net/geloin/article/details/7444321\">Spring MVC过滤器-HiddenHttpMethodFilter</a></span></address>', 4, 1, 0, 1, 1, 1, '2019-04-21 15:30:15', '2019-04-21 15:30:15');
INSERT INTO `article` VALUES (41, 1, 'HTTP协议', '<h1 class=\"title\"><span>HTTP简介</span></h1><div class=\"show-content\"><p><span>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。</span></p><p><span>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</span></p><p><span>HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。</span></p><p><span>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</span></p><p><img src=\"https://upload-images.jianshu.io/upload_images/2964446-5a35e17f298a48e1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2\"></p><h1><span>主要特点</span></h1><p><span>1、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</span></p><p><span>2、灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</span></p><p><span>3.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</span></p><p><span>4.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</span><br><span>5、支持B/S及C/S模式。</span></p><h1><span>HTTP之URL</span></h1><p><span>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息</span></p><p><span>URL,全称是UniformResourceLocator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。以下面这个URL为例，介绍下普通URL的各部分组成：</span></p><h4><span><a href=\"http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name\" target=\"_blank\">http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name</a></span></h4><p><span>从上面的URL可以看出，一个完整的URL包括以下几部分：</span><br><span>1.协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在\"HTTP\"后面的“//”为分隔符</span></p><p><span>2.域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用</span></p><p><span>3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口</span></p><p><span>4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”</span></p><p><span>5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名</span></p><p><span>6.锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分</span></p><p><span>7.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</span></p><p><span>（原文：<a href=\"http://blog.csdn.net/ergouge/article/details/8185219\" target=\"_blank\">http://blog.csdn.net/ergouge/article/details/8185219</a>&nbsp;）</span></p><h1><span>URI和URL的区别</span></h1><h5><span>URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。</span></h5><p><span>Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的</span><br><span>URI一般由三部组成：</span><br><span>①访问资源的命名机制</span><br><span>②存放资源的主机名</span><br><span>③资源自身的名称，由路径表示，着重强调于资源。</span></p><h5><span>URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。</span></h5><p><span>URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。</span><br><span>采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：</span><br><span>①协议(或称为服务方式)</span><br><span>②存有该资源的主机IP地址(有时也包括端口号)</span><br><span>③主机资源的具体地址。如目录和文件名等</span></p><h5><span>URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com。</span></h5><p><span>URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。</span></p><p><span>在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。</span><br><span>在Java类库中，URI类不包含任何访问资源的方法，它唯一的作用就是解析。</span><br><span>相反的是，URL类可以打开一个到达资源的流。</span></p><h1><span>HTTP之请求消息Request</span></h1><p><span>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：</span></p><p><span>请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。</span></p><p><img src=\"https://upload-images.jianshu.io/upload_images/2964446-fdfb1a8fce8de946.png?imageMogr2/auto-orient/strip%7CimageView2/2\"></p><div class=\"image-package imagebubble\"><div class=\"image-caption\"><span>Http请求消息结构.png</span></div></div><ul><li><span>请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本。</span></li></ul><h5><span>Get请求例子，使用Charles抓取的request：</span></h5><pre class=\"hljs cpp\"><span><code class=\"cpp\">GET /<span class=\"hljs-number\">562f25980001b1b106000338.jpg HTTP/<span class=\"hljs-number\">1.1\r\nHost    img.mukewang.com\r\nUser-Agent    Mozilla/<span class=\"hljs-number\">5.0 (Windows NT <span class=\"hljs-number\">10.0; WOW64) AppleWebKit/<span class=\"hljs-number\">537.36 (KHTML, like Gecko) Chrome/<span class=\"hljs-number\">51.0<span class=\"hljs-number\">.2704<span class=\"hljs-number\">.106 Safari/<span class=\"hljs-number\">537.36\r\nAccept    image/webp,image<span class=\"hljs-comment\">/*,*/*;q=<span class=\"hljs-number\">0.8\r\nReferer    http:<span class=\"hljs-comment\">//www.imooc.com/\r\nAccept-Encoding    gzip, deflate, sdch\r\nAccept-Language    zh-CN,zh;q=<span class=\"hljs-number\">0.8</span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre><h5><span>第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.</span></h5><p><span>GET说明请求类型为GET,[/562f25980001b1b106000338.jpg]为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。</span></p><h5><span>第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息</span></h5><p><span>从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等</span></p><h5><span>第三部分：空行，请求头部后面的空行是必须的</span></h5><p><span>即使第四部分的请求数据为空，也必须有空行。</span></p><h5><span>第四部分：请求数据也叫主体，可以添加任意的其他数据。</span></h5><p><span>这个例子的请求数据为空。</span></p><h5><span>POST请求例子，使用Charles抓取的request：</span></h5><pre class=\"hljs cpp\"><span><code class=\"cpp\">POST / HTTP1<span class=\"hljs-number\">.1\r\nHost:www.wrox.com\r\nUser-Agent:Mozilla/<span class=\"hljs-number\">4.0 (compatible; MSIE <span class=\"hljs-number\">6.0; Windows NT <span class=\"hljs-number\">5.1; SV1; .NET CLR <span class=\"hljs-number\">2.0<span class=\"hljs-number\">.50727; .NET CLR <span class=\"hljs-number\">3.0<span class=\"hljs-number\">.04506<span class=\"hljs-number\">.648; .NET CLR <span class=\"hljs-number\">3.5<span class=\"hljs-number\">.21022)\r\nContent-Type:application/x-www-form-urlencoded\r\nContent-Length:<span class=\"hljs-number\">40\r\nConnection: Keep-Alive\r\n\r\nname=Professional%<span class=\"hljs-number\">20Ajax&amp;publisher=Wiley</span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre><p><span>第一部分：请求行，第一行明了是post请求，以及http1.1版本。</span><br><span>第二部分：请求头部，第二行至第六行。</span><br><span>第三部分：空行，第七行的空行。</span><br><span>第四部分：请求数据，第八行。</span></p><h1><span>HTTP之响应消息Response</span></h1><p><span>一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。</span></p><p><span>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</span></p><p><img src=\"https://upload-images.jianshu.io/upload_images/2964446-1c4cab46f270d8ee.jpg?imageMogr2/auto-orient/strip%7CimageView2/2\"></p><div class=\"image-package imagebubble\"><div class=\"image-caption\"><span>http响应消息格式.jpg</span></div></div><p><span><strong>例子</strong></span></p><pre class=\"hljs xml\"><span><code class=\"xml\">HTTP/1.1 200 OK\r\nDate: Fri, 22 May 2009 06:07:21 GMT\r\nContent-Type: text/html; charset=UTF-8\r\n\r\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">html&gt;\r\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">head&gt;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">head&gt;\r\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">body&gt;\r\n            <span class=\"hljs-comment\">&lt;!--body goes here--&gt;\r\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">body&gt;\r\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">html&gt;</span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre><h5><span>第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。</span></h5><p><span>第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）</span></p><h5><span>第二部分：消息报头，用来说明客户端要使用的一些附加信息</span></h5><p><span>第二行和第三行为消息报头，</span><br><span>Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8</span></p><h5><span>第三部分：空行，消息报头后面的空行是必须的</span></h5><h5><span>第四部分：响应正文，服务器返回给客户端的文本信息。</span></h5><p><span>空行后面的html部分为响应正文。</span></p><h1><span>HTTP之状态码</span></h1><p><span>状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:</span></p><h6><span>1xx：指示信息--表示请求已接收，继续处理</span></h6><h6><span>2xx：成功--表示请求已被成功接收、理解、接受</span></h6><h6><span>3xx：重定向--要完成请求必须进行更进一步的操作</span></h6><h6><span>4xx：客户端错误--请求有语法错误或请求无法实现</span></h6><h6><span>5xx：服务器端错误--服务器未能实现合法的请求</span></h6><p><span>常见状态码：</span></p><pre class=\"hljs cpp\"><span><code class=\"cpp\"><span class=\"hljs-number\">200 OK                        <span class=\"hljs-comment\">//客户端请求成功\r\n<span class=\"hljs-number\">400 Bad Request               <span class=\"hljs-comment\">//客户端请求有语法错误，不能被服务器所理解\r\n<span class=\"hljs-number\">401 Unauthorized              <span class=\"hljs-comment\">//请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 \r\n<span class=\"hljs-number\">403 Forbidden                 <span class=\"hljs-comment\">//服务器收到请求，但是拒绝提供服务\r\n<span class=\"hljs-number\">404 Not Found                 <span class=\"hljs-comment\">//请求资源不存在，eg：输入了错误的URL\r\n<span class=\"hljs-number\">500 Internal Server Error     <span class=\"hljs-comment\">//服务器发生不可预期的错误\r\n<span class=\"hljs-number\">503 Server Unavailable        <span class=\"hljs-comment\">//服务器当前不能处理客户端的请求，一段时间后可能恢复正常</span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre><p><span>更多状态码<a href=\"http://www.runoob.com/http/http-status-codes.html\" target=\"_blank\">http://www.runoob.com/http/http-status-codes.html</a></span></p><h1><span>HTTP请求方法</span></h1><p><span>根据HTTP标准，HTTP请求可以使用多种请求方法。</span><br><span>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。</span><br><span>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</span></p><pre class=\"hljs sql\"><span><code class=\"sql\">GET     请求指定的页面信息，并返回实体主体。\r\nHEAD     类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头\r\nPOST     向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。\r\nPUT     从客户端向服务器传送的数据取代指定的文档的内容。\r\n<span class=\"hljs-operator\"><span class=\"hljs-keyword\">DELETE      请求服务器删除指定的页面。\r\n<span class=\"hljs-keyword\">CONNECT     <span class=\"hljs-keyword\">HTTP/<span class=\"hljs-number\">1.1协议中预留给能够将连接改为管道方式的代理服务器。\r\nOPTIONS     允许客户端查看服务器的性能。\r\n<span class=\"hljs-keyword\">TRACE     回显服务器收到的请求，主要用于测试或诊断。</span></span></span></span></span></span></code></span></pre><h1><span>HTTP工作原理</span></h1><p><span>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</span></p><p><span>以下是 HTTP 请求/响应的步骤：</span></p><h6><span>1、客户端连接到Web服务器</span></h6><p><span>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，<a href=\"http://www.oakcms.cn./\" target=\"_blank\">http://www.oakcms.cn。</a></span></p><h6><span>2、发送HTTP请求</span></h6><p><span>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</span></p><h6><span>3、服务器接受请求并返回HTTP响应</span></h6><p><span>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</span></p><h6><span>4、释放连接<a href=\"http://www.jianshu.com/p/ef892323e68f\" target=\"_blank\">TCP连接</a></span></h6><p><span>若connection 模式为close，则服务器主动关闭<a href=\"http://www.jianshu.com/p/ef892323e68f\" target=\"_blank\">TCP连接</a>，客户端被动关闭连接，释放<a href=\"http://www.jianshu.com/p/ef892323e68f\" target=\"_blank\">TCP连接</a>;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</span></p><h6><span>5、客户端浏览器解析HTML内容</span></h6><p><span>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</span></p><p><span>例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：</span></p><p><span>1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;</span></p><p><span>2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立<a href=\"http://www.jianshu.com/p/ef892323e68f\" target=\"_blank\">TCP连接</a>;</span></p><p><span>3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为&nbsp;<a href=\"http://www.jianshu.com/p/ef892323e68f\" target=\"_blank\">TCP 三次握手</a>的第三个报文的数据发送给服务器;</span></p><p><span>4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;</span></p><p><span>5、释放&nbsp;<a href=\"http://www.jianshu.com/p/ef892323e68f\" target=\"_blank\">TCP连接</a>;</span></p><p><span>6、浏览器将该 html 文本并显示内容; 　　</span></p><h1><span>GET和POST请求的区别</span></h1><h6><span>GET请求</span></h6><pre class=\"hljs cpp\"><span><code class=\"cpp\">GET /books/?sex=man&amp;name=Professional HTTP/<span class=\"hljs-number\">1.1\r\nHost: www.wrox.com\r\nUser-Agent: Mozilla/<span class=\"hljs-number\">5.0 (Windows; U; Windows NT <span class=\"hljs-number\">5.1; en-US; rv:<span class=\"hljs-number\">1.7<span class=\"hljs-number\">.6)\r\nGecko/<span class=\"hljs-number\">20050225 Firefox/<span class=\"hljs-number\">1.0<span class=\"hljs-number\">.1\r\nConnection: Keep-Alive</span></span></span></span></span></span></span></span></code></span></pre><p><span>注意最后一行是空行</span></p><h6><span>POST请求</span></h6><pre class=\"hljs cpp\"><span><code class=\"cpp\">POST / HTTP/<span class=\"hljs-number\">1.1\r\nHost: www.wrox.com\r\nUser-Agent: Mozilla/<span class=\"hljs-number\">5.0 (Windows; U; Windows NT <span class=\"hljs-number\">5.1; en-US; rv:<span class=\"hljs-number\">1.7<span class=\"hljs-number\">.6)\r\nGecko/<span class=\"hljs-number\">20050225 Firefox/<span class=\"hljs-number\">1.0<span class=\"hljs-number\">.1\r\nContent-Type: application/x-www-form-urlencoded\r\nContent-Length: <span class=\"hljs-number\">40\r\nConnection: Keep-Alive\r\n\r\nname=Professional%<span class=\"hljs-number\">20Ajax&amp;publisher=Wiley</span></span></span></span></span></span></span></span></span></span></code></span></pre><p><span>1、GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用&amp;连接；例 如：login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0 %E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。</span></p><p><span>POST提交：把提交的数据放置在是HTTP包的包体中。上文示例中红色字体标明的就是实际的传输数据</span></p><h6><span>因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变</span></h6><p><span>2、传输数据的大小：首先声明：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。</span></p><p><span>而在实际开发中存在的限制主要有：</span></p><p><span><strong>GET</strong>:特定浏览器和服务器对URL长度有限制，例如 IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系 统的支持。</span></p><p><span>因此对于GET提交时，传输数据就会受到URL长度的 限制。</span></p><p><span><strong>POST</strong>:由于不是通过URL传值，理论上数据不受 限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。</span></p><p><span>3、安全性</span></p><p><span>POST的安全性要比GET的安全性高。比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存；(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击</span></p><p><span>4、Http get,post,soap协议都是在http上运行的</span></p><p><span>（1）get：请求参数是作为一个key/value对的序列（查询字符串）附加到URL上的</span><br><span>查询字符串的长度受到web浏览器和web服务器的限制（如IE最多支持2048个字符），不适合传输大型数据集同时，它很不安全</span></p><p><span>（2）post：请求参数是在http标题的一个不同部分（名为entity body）传输的，这一部分用来传输表单信息，因此必须将Content-type设置为:application/x-www-form- urlencoded。post设计用来支持web窗体上的用户字段，其参数也是作为key/value对传输。</span><br><span>但是：它不支持复杂数据类型，因为post没有定义传输数据结构的语义和规则。</span></p><p><span>（3）soap：是http post的一个专用版本，遵循一种特殊的xml消息格式</span><br><span>Content-type设置为: text/xml 任何数据都可以xml化。</span></p><p><span>Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息.</span></p><p><span>我们看看GET和POST的区别</span></p><ol><ol><li><p><span>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中.</span></p></li><li><p><span>GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.</span></p></li><li><p><span>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。</span></p></li><li><p><span>GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.</span></p></li></ol></ol></div>', 8, 1, 3, 1, 1, 1, '2019-04-21 15:35:22', '2019-04-21 15:35:22');
INSERT INTO `article` VALUES (45, 1, '深入理解Java反射', '<p>要想理解反射的原理，首先要了解什么是类型信息。Java让我们在运行时识别对象和类的信息，主要有2种方式：一种是传统的RTTI，它假定我们在编译时已经知道了所有的类型信息；另一种是反射机制，它允许我们在运行时发现和使用类的信息。</p><h1>1、Class对象</h1><p>　　理解RTTI在Java中的工作原理，首先需要知道类型信息在运行时是如何表示的，这是由Class对象来完成的，它包含了与类有关的信息。Class对象就是用来创建所有“常规”对象的，Java使用Class对象来执行RTTI，即使你正在执行的是类似类型转换这样的操作。</p><p>　　每个类都会产生一个对应的Class对象，也就是保存在.class文件。所有类都是在对其第一次使用时，动态加载到JVM的，当程序创建一个对类的静态成员的引用时，就会加载这个类。Class对象仅在需要的时候才会加载，static初始化是在类加载时进行的。</p><div class=\"cnblogs_code\"><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div><pre><span>public</span> <span>class</span><span> TestMain {\r\n    </span><span>public</span> <span>static</span> <span>void</span><span> main(String[] args) {\r\n        System.out.println(XYZ.name);\r\n    }\r\n}\r\n\r\n</span><span>class</span><span> XYZ {\r\n    </span><span>public</span> <span>static</span> String name = \"luoxn28\"<span>;\r\n\r\n    </span><span>static</span><span> {\r\n        System.out.println(</span>\"xyz静态块\"<span>);\r\n    }\r\n\r\n    </span><span>public</span><span> XYZ() {\r\n        System.out.println(</span>\"xyz构造了\"<span>);\r\n    }\r\n}</span></pre><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div></div><p>输出结果为：</p><p><img src=\"https://images2015.cnblogs.com/blog/772134/201607/772134-20160720003120122-551868817.png\" alt=\"\"></p><p><span>　　类加载器首先会检查这个类的Class对象是否已被加载过，如果尚未加载，默认的类加载器就会根据类名查找对应的.class文件。</span></p><p>　　想在运行时使用类型信息，必须获取对象(比如类Base对象)的Class对象的引用，使用功能Class.forName(“Base”)可以实现该目的，或者使用base.class。注意，有一点很有趣，使用功能”.class”来创建Class对象的引用时，不会自动初始化该Class对象，使用forName()会自动初始化该Class对象。为了使用类而做的准备工作一般有以下3个步骤：</p><ul><li>加载：由类加载器完成，找到对应的字节码，创建一个Class对象</li><li>链接：验证类中的字节码，为静态域分配空间</li><li>初始化：如果该类有超类，则对其初始化，执行静态初始化器和静态初始化块</li></ul><div class=\"cnblogs_code\"><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div><pre><span>public</span> <span>class</span><span> Base {\r\n    </span><span>static</span> <span>int</span> num = 1<span>;\r\n    \r\n    </span><span>static</span><span> {\r\n        System.out.println(</span>\"Base \" +<span> num);\r\n    }\r\n}\r\n</span><span>public</span> <span>class</span><span> Main {\r\n    </span><span>public</span> <span>static</span> <span>void</span><span> main(String[] args) {\r\n        </span><span>//</span><span> 不会初始化静态块</span>\r\n        Class clazz1 = Base.<span>class</span><span>;\r\n        System.out.println(</span>\"------\"<span>);\r\n        </span><span>//</span><span> 会初始化</span>\r\n        Class clazz2 = Class.forName(\"zzz.Base\"<span>);\r\n    }\r\n}</span></pre><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div></div><h1>2、类型转换前先做检查</h1><p>　　编译器将检查类型向下转型是否合法，如果不合法将抛出异常。向下转换类型前，可以使用instanceof判断。</p><div class=\"cnblogs_code\"><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div><pre><span>class</span><span> Base { }\r\n</span><span>class</span> Derived <span>extends</span><span> Base { }\r\n\r\n</span><span>public</span> <span>class</span><span> Main {\r\n    </span><span>public</span> <span>static</span> <span>void</span><span> main(String[] args) {\r\n        Base base </span>= <span>new</span><span> Derived();\r\n        </span><span>if</span> (base <span>instanceof</span><span> Derived) {\r\n            </span><span>//</span><span> 这里可以向下转换了</span>\r\n            System.out.println(\"ok\"<span>);\r\n        }\r\n        </span><span>else</span><span> {\r\n            System.out.println(</span>\"not ok\"<span>);\r\n        }\r\n    }\r\n}</span></pre><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div></div><h1>3、反射：运行时类信息</h1><p>　　如果不知道某个对象的确切类型，RTTI可以告诉你，但是有一个前提：这个类型在编译时必须已知，这样才能使用RTTI来识别它。Class类与java.lang.reflect类库一起对反射进行了支持，该类库包含Field、Method和Constructor类，这些类的对象由JVM在启动时创建，用以表示未知类里对应的成员。这样的话就可以使用Contructor创建新的对象，用get()和set()方法获取和修改类中与Field对象关联的字段，用invoke()方法调用与Method对象关联的方法。另外，还可以调用getFields()、getMethods()和getConstructors()等许多便利的方法，以返回表示字段、方法、以及构造器对象的数组，这样，对象信息可以在运行时被完全确定下来，而在编译时不需要知道关于类的任何事情。</p><p>　　反射机制并没有什么神奇之处，当通过反射与一个未知类型的对象打交道时，JVM只是简单地检查这个对象，看它属于哪个特定的类。因此，那个类的<code>.class</code>对于JVM来说必须是可获取的，要么在本地机器上，要么从网络获取。所以对于RTTI和反射之间的真正区别只在于：</p><ul><li>RTTI，编译器在编译时打开和检查.class文件</li><li>反射，运行时打开和检查.class文件</li></ul><div class=\"cnblogs_code\"><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div><pre><span>public</span> <span>class</span> Person <span>implements</span><span> Serializable {\r\n\r\n    </span><span>private</span><span> String name;\r\n    </span><span>private</span> <span>int</span><span> age;\r\n</span><span>//</span><span> get/set方法</span>\r\n<span>}\r\n</span><span>public</span> <span>static</span> <span>void</span><span> main(String[] args) {\r\n    Person person </span>= <span>new</span> Person(\"luoxn28\", 23<span>);\r\n    Class clazz </span>=<span> person.getClass();\r\n\r\n    Field[] fields </span>=<span> clazz.getDeclaredFields();\r\n    </span><span>for</span><span> (Field field : fields) {\r\n        String key </span>=<span> field.getName();\r\n        PropertyDescriptor descriptor </span>= <span>new</span><span> PropertyDescriptor(key, clazz);\r\n        Method method </span>=<span> descriptor.getReadMethod();\r\n        Object value </span>=<span> method.invoke(person);\r\n\r\n        System.out.println(key </span>+ \":\" +<span> value);\r\n\r\n    }\r\n}</span></pre><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div></div><p>　　以上通过getReadMethod()方法调用类的get函数，可以通过getWriteMethod()方法来调用类的set方法。通常来说，我们不需要使用反射工具，但是它们在创建动态代码会更有用，反射在Java中用来支持其他特性的，例如对象的序列化和JavaBean等。</p><h1>4、动态代理</h1><p>　　代理模式是为了提供额外或不同的操作，而插入的用来替代”实际”对象的对象，这些操作涉及到与”实际”对象的通信，因此代理通常充当中间人角色。Java的动态代理比代理的思想更前进了一步，它可以动态地创建并代理并动态地处理对所代理方法的调用。在动态代理上所做的所有调用都会被重定向到单一的<strong>调用处理器</strong>上，它的工作是揭示调用的类型并确定相应的策略。以下是一个动态代理示例：</p><p><strong>接口和实现类：</strong></p><div class=\"cnblogs_code\"><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div><pre><span>public</span> <span>interface</span><span> Interface {\r\n    </span><span>void</span><span> doSomething();\r\n    </span><span>void</span><span> somethingElse(String arg);\r\n}\r\n</span><span>public</span> <span>class</span> RealObject <span>implements</span><span> Interface {\r\n    </span><span>public</span> <span>void</span><span> doSomething() {\r\n        System.out.println(</span>\"doSomething.\"<span>);\r\n    }\r\n    </span><span>public</span> <span>void</span><span> somethingElse(String arg) {\r\n        System.out.println(</span>\"somethingElse \" +<span> arg);\r\n    }\r\n}</span></pre><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div></div><p><strong>动态代理对象处理器：</strong></p><div class=\"cnblogs_code\"><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div><pre><span>public</span> <span>class</span> DynamicProxyHandler <span>implements</span><span> InvocationHandler {\r\n    </span><span>private</span><span> Object proxyed;\r\n    \r\n    </span><span>public</span><span> DynamicProxyHandler(Object proxyed) {\r\n        </span><span>this</span>.proxyed =<span> proxyed;\r\n    }\r\n    \r\n    @Override\r\n    </span><span>public</span> Object invoke(Object proxy, Method method, Object[] args) <span>throws</span><span> IllegalAccessException, IllegalArgumentException, InvocationTargetException {\r\n        System.out.println(</span>\"代理工作了.\"<span>);\r\n        </span><span>return</span><span> method.invoke(proxyed, args);\r\n    }\r\n}</span></pre><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div></div><p><strong>测试类：</strong></p><div class=\"cnblogs_code\"><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div><pre><span>public</span> <span>class</span><span> Main {\r\n    </span><span>public</span> <span>static</span> <span>void</span><span> main(String[] args) {\r\n        RealObject real </span>= <span>new</span><span> RealObject();\r\n        Interface proxy </span>=<span> (Interface) Proxy.newProxyInstance(\r\n                Interface.</span><span>class</span>.getClassLoader(), <span>new</span> Class[] {Interface.<span>class</span><span>},\r\n                </span><span>new</span><span> DynamicProxyHandler(real));\r\n        \r\n        proxy.doSomething();\r\n        proxy.somethingElse(</span>\"luoxn28\"<span>);\r\n    }\r\n}</span></pre><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div></div><p><strong>输出结果如下：</strong></p><p><img src=\"https://images2015.cnblogs.com/blog/772134/201607/772134-20160720215750576-147236062.png\" alt=\"\"></p><p>　　通过调用Proxy静态方法Proxy.newProxyInstance()可以创建动态代理，这个方法需要得到一个类加载器，一个你希望该代理实现的接口列表(不是类或抽象类)，以及InvocationHandler的一个实现类。动态代理可以将所有调用重定向到调用处理器，因此通常会调用处理器的构造器传递一个”实际”对象的引用，从而将调用处理器在执行中介任务时，将请求转发。</p>', 5, 1, 0, 1, 1, 1, '2019-04-21 16:33:06', '2019-04-21 16:33:06');
INSERT INTO `article` VALUES (46, 1, '江海不渡你', '<p><span>作曲 : 余心</span><br></p><p><span>作词：诗人凉</span></p><p><span><br></span></p><span>在梦中哼着</span><br><span>她曾经最爱的歌谣</span><br><span>我们的悲伤无处可逃</span><br><span>那被花开覆盖着</span><br><span>城外那座拱桥</span><br><span>你的路途归期遥遥</span><br><span>相逢一醉</span><br><span>抵不过今日细雨毛毛</span><br><span>积水埋没你不痛丝毫</span><br><span>黑色的飞鸟</span><br><span>它掠过了江海潮潮</span><br><span>我为你渡过了煎熬</span><br><span>这长街星在闪烁</span><br><span>烟雨轻带些涩</span><br><span>我把萧再云声色</span><br><span>叹这长裙已破</span><br><span>一曲沧笙的情歌</span><br><span>没有谣传去说</span><br><span>乌云蔽月情负多</span><br><span>老酒在一人喝</span><br><span>梅花落在了肩头</span><br><span>问这是何缘由</span><br><span>清远的人还在愁</span><br><span>葬在情的温柔</span><br><span>折尽梅花垂柳树</span><br><span>可却神明已负</span><br><span>情迷雾却无人渡</span><br><span>江海不渡我来渡</span><br><span>命运不渡你</span><br><span>天地不渡你</span><br><span>江海不渡你</span><br><span>我渡</span><br><span>在梦中哼着</span><br><span>她曾经最爱的歌谣</span><br><span>我们的悲伤无处可逃</span><br><span>那被花开覆盖着</span><br><span>城外那座拱桥</span><br><span>你的路途归期遥遥</span><br><span>相逢一醉</span><br><span>抵不过今日细雨毛毛</span><br><span>积水埋没你不痛丝毫</span><br><span>黑色的飞鸟</span><br><span>它掠过了江海潮潮</span><br><span>我为你渡过了煎熬</span><p></p>', 7, 0, 0, 1, 1, 1, '2019-04-23 10:50:48', '2019-04-21 18:13:29');
INSERT INTO `article` VALUES (47, 1, '注解@Slf4j', '<p><span>如果不想每次都写</span>private&nbsp; final Logger logger = LoggerFactory.getLogger(XXX.class);&nbsp;<span>可以用注解</span><span>@Slf4j</span></p><p><span>一、在</span>pom<span>文件加入依赖</span></p><p>&lt;dependency&gt;<br>&nbsp;&nbsp;&nbsp;&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;<br>&nbsp;&nbsp;&nbsp;&lt;artifactId&gt;lombok&lt;/artifactId&gt;<br>&lt;/dependency&gt;</p><p><span>二</span><span>、</span><span>代码</span></p><p>package com.sell;<br>import lombok.extern.slf4j.Slf4j;<br>import org.junit.Test;<br>import org.slf4j.Logger;<br>import org.slf4j.LoggerFactory;<br>import org.junit.runner.RunWith;<br>import org.springframework.boot.test.context.SpringBootTest;<br>import org.springframework.test.context.junit4.SpringRunner;<br><br><em>/**</em><em><br></em><em>&nbsp;* &nbsp;&nbsp;日志测试</em><em><br></em><em>&nbsp;*/</em><em><br></em><em><br></em>@RunWith(SpringRunner.class)<br>@SpringBootTest<br>@Slf4j<br>public class LoggerTest {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;private &nbsp;final Logger logger = LoggerFactory.<em>getLogger</em>(LoggerTest.class);<br>&nbsp;&nbsp;&nbsp;&nbsp;<em>/**</em><em><br></em><em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* 一、传统方式实现日志</em><em><br></em><em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</em><em><br></em><em>&nbsp;&nbsp;&nbsp;&nbsp;</em>@Test<br>&nbsp;&nbsp;&nbsp;&nbsp;public &nbsp;void test1(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.debug(\"debug message\");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.warn(\"warn message\");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.info(\"info message\");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.error(\"error message\");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.trace(\"trace message\");<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;<em>/**</em><em><br></em><em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* 二、注解方式实现日志</em><em><br></em><em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</em><em><br></em><em>&nbsp;&nbsp;&nbsp;&nbsp;</em>@Test<br>&nbsp;&nbsp;&nbsp;public &nbsp;void test2(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>log</em>.debug(\"debug message\");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>log</em>.warn(\"warn message\");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>log</em>.info(\"info message\");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>log</em>.error(\"error message\");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>log</em>.trace(\"trace message\");<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>}</p><p>&nbsp;</p><p><span>输出如下：</span></p><p><img src=\"https://images2017.cnblogs.com/blog/727732/201710/727732-20171007005038333-722076757.png\" alt=\"\"></p><p><span>因为默认是输出</span>&nbsp;info<span>之上的&nbsp;</span><span>，</span>&nbsp;<span>由下图可知</span>&nbsp;debug<span>，</span>trace<span>不输出</span></p><p><img src=\"https://images2017.cnblogs.com/blog/727732/201710/727732-20171007005125724-514302687.png\" alt=\"\"></p><p>&nbsp;</p><p>三、<span>注意：如果注解</span>@Slf4j<span>注入后找不到变量</span><span>log</span><span>，那就给</span><span>IDE</span><span>安装</span><span>lombok</span><span>插件，、</span></p><p><span>下面以</span>idea<span>为例</span></p><p>1<span>、</span><span>File &nbsp;</span><span>→&nbsp;</span><span>settings&nbsp;</span><span>→ &nbsp;</span><span>Plugins, &nbsp;</span><span>然后点击“</span><span>Browse repositories</span><span>” 如图</span></p><p><img src=\"https://images2017.cnblogs.com/blog/727732/201710/727732-20171007005153630-156372538.png\" alt=\"\"></p><p>&nbsp;</p><p>2<span>、输入&nbsp;</span><span>lombok&nbsp;</span><span>搜索插件， 点</span><span>install</span><span>安装，安装完重启</span><span>idea</span></p><p><img src=\"https://images2017.cnblogs.com/blog/727732/201710/727732-20171007005212755-557704490.png\" alt=\"\"></p><p>&nbsp;</p><p>&nbsp;</p><p><span>这时候输入</span>&nbsp;log<span>就可以有提示了</span></p>', 6, 4, 0, 1, 1, 1, '2019-04-23 10:05:26', '2019-04-23 10:05:26');
INSERT INTO `article` VALUES (43, 1, 'Linux常用命令学习', '<h1>1、ls命令</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 就是list的缩写，通过ls 命令不仅可以查看linux文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限)查看目录信息等等</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 常用参数搭配：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ls -a 列出目录所有文件，包含以.开始的隐藏文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ls -A 列出除.及..的其它文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ls -r 反序排列</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ls -t 以文件修改时间排序</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ls -S 以文件大小排序</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ls -h 以易读大小显示</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ls -l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实例：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1) 按易读方式按时间反序排序，并显示文件详细信息</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ls -lhrt</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (2) 按大小反序显示文件详细信息</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ls -lrS</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (3)列出当前目录中所有以“t”开头的目录的详细内容</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ls -l t*</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (4) 列出文件绝对路径（不包含隐藏文件）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ls | sed \"s:^:`pwd`/:\"</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (5) 列出文件绝对路径（包含隐藏文件）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; find $pwd -maxdepth 1 | xargs ls -ld</p><p>&nbsp;</p><h1>2、cd命令</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (changeDirectory),命令语法：cd [目录名]。说明：切换当前目录至dirName</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实例：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （1）进入要目录</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cd /</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （2）进入\"家\"目录</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cd ~</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （3）进入上一次工作路径</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cd -</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （4）把上个命令的参数作为cd参数使用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cd !$</p><h1>3、pwd命令</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 查看当前工作目录路径</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实例：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （1）查看当前路径</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pwd</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （2）查看软链接的实际路径</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pwd -P</p><h1>4、mkdir命令</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 创建文件夹</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 可用选项：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -m: 对新建目录设置存取权限,也可以用chmod命令设置;</p><p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -p: 可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 些尚不在的目录,即一次可以建立多个目录;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实例：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （1）当前工作目录下创建名为t的文件夹</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mkdir t</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （2）在tmp目录下创建路径为test/t1/t的目录，若不存在，则创建</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mkdir -p /tmp/test/t1/t</p><h1>5、rm命令</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 删除一个目录中的一个或多个文件或目录，如果没有使用- r选项，则rm不会删除目录。如果使用 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rm 来删除文件，通常仍可以将该文件恢复原状</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rm [选项] 文件…</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实例：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （1）删除任何.log文件；删除前逐一询问确认</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rm -i *.log</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （2）删除test子目录及子目录中所有档案删除,并且不用一一确认</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rm -rf test</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （3）删除以-f开头的文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rm -- -f*</p><h1>6、rmdir命令</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 从一个目录中删除一个或多个子目录项，删除某目录时也必须具有对其父目录的写权限。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 注意：不能删除非空目录</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实例：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （1）当parent子目录被删除后使它也成为空目录的话，则顺便一并删除</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rmdir -p parent/child/child11</p><h1>7、mv命令</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 移动文件或修改文件名，根据第二参数类型（如目录，则移动文件；如为文件则重命令该文件）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当第二个参数为目录时，可刚多个文件以空格分隔作为第一参数，移动多个文件到参数2指定的目录中</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实例：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （1）将文件test.log重命名为test1.txt</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mv test.log test1.txt</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （2）将文件log1.txt,log2.txt,log3.txt移动到根的test3目录中</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mv llog1.txt log2.txt log3.txt /test3</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （3）将文件file1改名为file2，如果file2已经存在，则询问是否覆盖</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mv -i log1.txt log2.txt</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （4）移动当前文件夹下的所有文件到上一级目录</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mv * ../</p><h1>8、cp命令</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 将源文件复制至目标文件，或将多个源文件复制至目标目录。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 注意：命令行复制，如果目标文件已经存在会提示是否覆盖，而在shell脚本中，如果不加-i参数，则不会提示，而是直接覆盖！</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -i 提示</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -r 复制目录及目录内所有项目</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -a 复制的文件与原文件时间一样</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实例：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （1）复制a.txt到test目录下，保持原文件时间,如果原文件存在提示是否覆盖</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cp -ai a.txt test</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （2）为a.txt建议一个链接（快捷方式）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cp -s a.txt link_a.txt</p><h1>9、cat命令</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cat主要有三大功能：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.一次显示整个文件:cat filename</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.从键盘创建一个文件:cat &gt; filename 只能创建新文件,不能编辑已有文件.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.将几个文件合并为一个文件:cat file1 file2 &gt; file</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -b对非空输出行号</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -n输出所有行号</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实例：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （1）把 log2012.log 的文件内容加上行号后输入 log2013.log 这个文件里</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cat -n log2012.log log2013.log</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （2）把 log2012.log 和 log2013.log 的文件内容加上行号（空白行不加）之后将内容附加到 log.log 里</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cat -b log2012.log log2013.log log.log</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （3）使用here doc生成新文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cat &gt;log.txt &lt;&lt;EOF</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;Hello</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;World</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;PWD=$(pwd)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;EOF</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ls -l log.txt</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cat log.txt</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Hello</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; World</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PWD=/opt/soft/test</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （4）反向列示</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tac log.txt</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PWD=/opt/soft/test</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; World</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Hello</p><h1>10、more命令</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 功能类似于cat, more会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt;&gt;命令参数：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 从笫n行开始显示</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 定义屏幕大小为n行</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 从顶部清屏，然后显示</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 忽略Ctrl+l（换页）字符</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -p&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 把连续的多个空行显示为一行</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -u&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 把文件内容中的下画线去掉</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt;&gt;常用操作命令：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Enter&nbsp;&nbsp;&nbsp; 向下n行，需要定义。默认为1行</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ctrl+F&nbsp;&nbsp; 向下滚动一屏</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 空格键&nbsp; 向下滚动一屏</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ctrl+B&nbsp; 返回上一屏</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 输出当前行的行号</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ：f&nbsp;&nbsp;&nbsp;&nbsp; 输出文件名和当前行的行号</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 调用vi编辑器</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !命令&nbsp;&nbsp; 调用Shell，并执行命令</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; q&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 退出more</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实例：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （1）显示文件中从第3行起的内容</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; more +3 text.txt</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （2）在所列出文件目录详细信息，借助管道使每次显示5行</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ls -l | more -5</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 按空格显示下5行</p><h1>11、less命令</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 常用命令参数</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -i&nbsp; 忽略搜索时的大小写</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -N&nbsp; 显示每行的行号</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -o&nbsp; &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -s&nbsp; 显示连续空行为一行</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /字符串：向下搜索“字符串”的功能</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ?字符串：向上搜索“字符串”的功能</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n：重复前一个搜索（与 / 或 ? 有关）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; N：反向重复前一个搜索（与 / 或 ? 有关）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -x &lt;数字&gt; 将“tab”键显示为规定的数字空格</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b&nbsp; 向后翻一页</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d&nbsp; 向后翻半页</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; h&nbsp; 显示帮助界面</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Q&nbsp; 退出less 命令</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u&nbsp; 向前滚动半页</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y&nbsp; 向前滚动一行</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 空格键 滚动一行</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 回车键 滚动一页</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [pagedown]： 向下翻动一页</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [pageup]：&nbsp;&nbsp; 向上翻动一页</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实例：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （1）ps查看进程信息并通过less分页显示</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ps -aux | less -N</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （2）查看多个文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; less 1.log 2.log</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 可以使用n查看下一个，使用p查看前一个</p><h1>12、head命令</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; head 用来显示档案的开头至标准输出中，默认head命令打印其相应文件的开头10行。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 常用参数：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -n&lt;行数&gt; 显示的行数（行数为复数表示从最后向前数）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实例：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （1）显示1.log文件中前20行</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; head 1.log -n 20</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （2）显示1.log文件前20字节</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; head -c 20 log2014.log</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （3）显示t.log最后10行</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; head -n -10 t.log</p><h1>13、tail命令</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 常用参数：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -f 循环读取（常用于查看递增的日志文件）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -n&lt;行数&gt; 显示行数（从后向前）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （1）循环读取逐渐增加的文件内容</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ping 127.0.0.1 &gt; ping.log &amp;（后台运行：可使用jobs -l查看，也可使用fg将其移到前台运行）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tail -f ping.log（查看日志）</p><h1>14、which命令</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在linux要查找某个文件，但不知道放在哪里了，可以使用下面的一些命令来搜索：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; which&nbsp; &nbsp;&nbsp; 查看可执行文件的位置。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; whereis 查看文件的位置。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; locate&nbsp; 配合数据库查看文件位置。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; find&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; 实际搜寻硬盘查询文件名称。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; which是在PATH就是指定的路径中，搜索某个系统命令的位置，并返回第一个搜索结果。使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 常用参数：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -n 　指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实例：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （1）查看ls命令是否存在，执行哪个</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; which ls</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （2）查看which</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; which which</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （3）查看cd</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; which cd（显示不存在，因为cd是内建命令，而which查找显示是PATH中的命令）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 查看当前PATH配置：echo $PATH；或使用env查看所有环境变量及对应值</p><h1>15、whereis命令</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。whereis及locate都是基于系统内建的数据库进行搜索，因此效率很高，而find则是遍历硬盘查找文件。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 常用参数：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -b&nbsp;&nbsp; 定位可执行文件。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -m&nbsp;&nbsp; 定位帮助文件。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -s&nbsp;&nbsp; 定位源代码文件。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -u&nbsp;&nbsp; 搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实例：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （1）查找locate程序相关文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; whereis locate</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （2）查找locate的源码文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; whereis -s locate</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （3）查找lcoate的帮助文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; whereis -m locate</p><h1>16、locate命令</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; locate通过搜寻系统内建文档数据库达到快速找到档案，数据库由updatedb程序来更新，updatedb是由cron daemon周期性调用的。默认情况下locate命令在搜寻数据库时比由整个由硬盘资料来搜寻资料来得快，但较差劲的是locate所找到的档案若是最近才建立或 刚更名的，可能会找不到，在内定值中，updatedb每天会跑一次，可以由修改crontab来更新设定值。(etc/crontab)。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; locate与find命令相似，可以使用如*、?等进行正则匹配查找</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 常用参数：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -l num（要显示的行数）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -f&nbsp;&nbsp; 将特定的档案系统排除在外，如将proc排除在外</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -r&nbsp;&nbsp; 使用正则运算式做为寻找条件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实例：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （1）查找和pwd相关的所有文件(文件名中包含pwd）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; locate pwd</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （2）搜索etc目录下所有以sh开头的文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; locate /etc/sh</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （3）查找/var目录下，以reason结尾的文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; locate -r \'^/var.*reason$\'（其中.表示一个字符，*表示任务多个；.*表示任意多个字符）</p><h1>17、find命令</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 用于在文件树中查找文件，并作出相应的处理</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 命令格式：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; find pathname -options [-print -exec -ok ...]</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 命令参数：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pathname: find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -print： find命令将匹配的文件输出到标准输出。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为\'command\' {&nbsp; } \\;，注意{&nbsp;&nbsp; }和\\；之间的空格。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -ok： 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 命令选项：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -name 按照文件名查找文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -perm 按文件权限查找文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -user 按文件属主查找文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -group&nbsp; 按照文件所属的组来查找文件。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -type&nbsp; 查找某一类型的文件，诸如：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b - 块设备文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d - 目录</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c - 字符设备文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l - 符号链接文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p - 管道文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f - 普通文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -size n :[c] 查找文件长度为n块文件，带有c时表文件字节大小</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -amin n&nbsp;&nbsp; 查找系统中最后N分钟访问的文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -atime n&nbsp; 查找系统中最后n*24小时访问的文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -cmin n&nbsp;&nbsp; 查找系统中最后N分钟被改变文件状态的文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -ctime n&nbsp; 查找系统中最后n*24小时被改变文件状态的文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -mmin n&nbsp;&nbsp; 查找系统中最后N分钟被改变文件数据的文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -mtime n&nbsp; 查找系统中最后n*24小时被改变文件数据的文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (用减号-来限定更改时间在距今n日以内的文件，而用加号+来限定更改时间在距今n日以前的文件。 )</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -maxdepth n 最大查找目录深度</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -prune选项来指出需要忽略的目录。在使用-prune选项时要当心，因为如果你同时使用了-depth选项，那么-prune选项就会被find命令忽略</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -newer 如果希望查找更改时间比某个文件新但比另一个文件旧的所有文件，可以使用-newer选项</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实例：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （1）查找48小时内修改过的文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; find -atime -2</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （2）在当前目录查找 以.log结尾的文件。 \". \"代表当前目录</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; find ./ -name \'*.log\'</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （3）查找/opt目录下 权限为 777的文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; find /opt -perm 777</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （4）查找大于1K的文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; find -size +1000c</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; find -size 1000c 查找等于1000字符的文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -exec&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 参数后面跟的是command命令，它的终止是以;为结束标志的，所以这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所以前面加反斜杠。{}&nbsp;&nbsp; 花括号代表前面find查找出来的文件名。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实例：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （5）在当前目录中查找更改时间在10日以前的文件并删除它们(无提醒）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; find . -type f -mtime +10 -exec rm -f {} \\;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （6）当前目录中查找所有文件名以.log结尾、更改时间在5日以上的文件，并删除它们，只不过在删除之前先给出提示。 按y键删除文件，按n键不删除</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; find . -name \'*.log\' mtime +5 -ok -exec rm {} \\;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （7）当前目录下查找文件名以passwd开头，内容包含\"pkg\"字符的文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; find . -f -name \'passwd*\' -exec grep \"pkg\" {} \\;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （8）用exec选项执行cp命令&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; find . -name \'*.log\' -exec cp {} test3 \\;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -xargs find命令把匹配到的文件传递给xargs命令，而xargs命令每次只获取一部分文件而不是全部，不像-exec选项那样。这样它可以先处理最先获取的一部分文件，然后是下一批，并如此继续下去。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实例：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （9）查找当前目录下每个普通文件，然后使用xargs来判断文件类型</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; find . -type f -print | xargs file</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （10）查找当前目录下所有以js结尾的并且其中包含\'editor\'字符的普通文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; find . -type f -name \"*.js\" -exec grep -lF \'ueditor\' {} \\;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; find -type f -name \'*.js\' | xargs grep -lF \'editor\'</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （11）利用xargs执行mv命令</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; find . -name \"*.log\" | xargs -i mv {} test4</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （12）用grep命令在当前目录下的所有普通文件中搜索hostnames这个词,并标出所在行</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; find . -name \\*(转义） -type f -print | xargs grep -n \'hostnames\'</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （13）查找当前目录中以一个小写字母开头，最后是4到9加上.log结束的文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; find . -name \'[a-z]*[4-9].log\' -print</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （14）在test目录查找不在test4子目录查找</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; find test -path \'test/test4\' -prune -o -print</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （15）实例1：查找更改时间比文件log2012.log新但比文件log2017.log旧的文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; find -newer log2012.log ! -newer log2017.log</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用depth选项：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; depth选项可以使find命令向磁带上备份文件系统时，希望首先备份所有的文件，其次再备份子目录中的文件。&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实例：find命令从文件系统的根目录开始，查找一个名为CON.FILE的文件。 它将首先匹配所有的文件然后再进入子目录中查找</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; find / -name \"CON.FILE\" -depth -print</p><h1>18、chmod命令</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 用于改变linux系统文件或目录的访问权限。用它控制文件或目录的访问权限。该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 每一文件或目录的访问权限都有三组，每组用三位表示，分别为文件属主的读、写和执行权限；与属主同组的用户的读、写和执行权限；系统中其他用户的读、写和执行权限。可使用ls -l test.txt查找</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 以文件log2012.log为例：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -rw-r--r-- 1 root root 296K 11-13 06:03 log2012.log</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 第一列共有10个位置，第一个字符指定了文件类型。在通常意义上，一个目录也是一个文件。如果第一个字符是横线，表示是一个非目录的文件。如果是d，表示是一个目录。从第二个字符开始到第十个共9个字符，3个字符一组，分别表示了3组用户对文件或者目录的权限。权限字符用横线代表空许可，r代表只读，w代表写，x代表可执行。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 常用参数：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -c 当发生改变时，报告处理信息</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -R 处理指定目录以及其子目录下所有文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 权限范围：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u ：目录或者文件的当前的用户</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g ：目录或者文件的当前的群组</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; o ：除了目录或者文件的当前用户或群组之外的用户或者群组</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a ：所有的用户及群组</p><p>&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 权限代号：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r ：读权限，用数字4表示</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; w ：写权限，用数字2表示</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x ：执行权限，用数字1表示</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - ：删除权限，用数字0表示</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s ：特殊权限</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实例：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （1）增加文件t.log所有用户可执行权限</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chmod a+x t.log</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （2）撤销原来所有的权限，然后使拥有者具有可读权限,并输出处理信息</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chmod u=r t.log -c</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （3）给file的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chmod 751 t.log -c（或者：chmod u=rwx,g=rx,o=x t.log -c)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （4）将test目录及其子目录所有文件添加可读权限</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chmod u+r,g+r,o+r -R text/ -c</p><h1>19、tar命令</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 用来压缩和解压文件。tar本身不具有压缩功能，只具有打包功能，有关压缩及解压是调用其它的功能来完成。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 常用参数：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -c 建立新的压缩文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -f 指定压缩文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -r 添加文件到已经压缩文件包中</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -u 添加改了和现有的文件到压缩包中</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -x 从压缩包中抽取文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -t 显示压缩文件中的内容</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -z 支持gzip压缩</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -j 支持bzip2压缩</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -Z 支持compress解压文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -v 显示操作过程</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 有关gzip及bzip2压缩</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gzip实例：压缩gzip fileName .tar.gz和.tgz&nbsp; 解压：gunzip filename.gz或gzip -d filename.gz</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对应：tar zcvf filename.tar.gz&nbsp;&nbsp;&nbsp;&nbsp; tar zxvf filename.tar.gz</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bz2实例：压缩bzip2 -z filename .tar.bz2 解压：bunzip filename.bz2或bzip -d filename.bz2</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对应：tar jcvf filename.tar.gz&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 解压：tar jxvf filename.tar.bz2</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实例：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （1）将文件全部打包成tar包</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tar -cvf log.tar 1.log,2.log 或tar -cvf log.*</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （2）将/etc下的所有文件及目录打包到指定目录，并使用gz压缩</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tar -zcvf /tmp/etc.tar.gz /etc</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （3）查看刚打包的文件内容（一定加z，因为是使用gzip压缩的）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tar -ztvf /tmp/etc.tar.gz</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （4）要压缩打包/home, /etc ，但不要 /home/dmtsai</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tar --exclude /home/dmtsai -zcvf myfile.tar.gz /home/* /etc</p><h1>20、chown命令</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chown将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户ID；组可以是组名或者组ID；文件是以空格分开的要改变权限的文件列表，支持通配符</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -c 显示更改的部分的信息</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -R 处理指定目录及子目录</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实例：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （1）改变拥有者和群组 并显示改变信息</p><p>　　　　chown -c mail:mail log2012.log</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （2）改变文件群组</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chown -c :mail t.log</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （3）改变文件夹及子文件目录属主及属组为mail</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chown -cR mail: test/</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （4）改变文件</p><h1>21、df命令</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 显示磁盘空间使用情况。获取硬盘被占用了多少空间，目前还剩下多少空间等信息，如果没有文件名被指定，则所有当前被挂载的文件系统的可用空间将被显示。默认情况下，磁盘空间将以 1KB 为单位进行显示，除非环境变量 POSIXLY_CORRECT 被指定，那样将以512字节为单位进行显示</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -a 全部文件系统列表</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -h 以方便阅读的方式显示信息</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -i 显示inode信息</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -k 区块为1024字节</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -l 只显示本地磁盘</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -T 列出文件系统类型</p><p>&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实例：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （1）显示磁盘使用情况</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; df -l</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （2）以易读方式列出所有文件系统及其类型</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; df -haT</p><h1>22、du命令</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; du命令也是查看使用空间的，但是与df命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查看</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 命令格式：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; du [选项] [文件]</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 常用参数：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -a 显示目录中所有文件大小</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -k 以KB为单位显示文件大小</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -m 以MB为单位显示文件大小</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -g 以GB为单位显示文件大小</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -h 以易读方式显示文件大小</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -s 仅显示总计</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -c或--total&nbsp; 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实例：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （1）以易读方式显示文件夹内及子文件夹大小</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; du -h scf/</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （2）以易读方式显示文件夹内所有文件大小</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; du -ah scf/</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （3）显示几个文件或目录各自占用磁盘空间的大小，还统计它们的总和</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; du -hc test/ scf/</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （4）输出当前目录下各个子目录所使用的空间</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; du -hc --max-depth=1 scf/</p><h1>23、ln命令</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 功能是为文件在另外一个位置建立一个同步的链接，当在不同目录需要该问题时，就不需要为每一个目录创建同样的文件，通过ln创建的链接（link）减少磁盘占用量。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 链接分类：软件链接及硬链接</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 软链接：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.软链接可以 跨文件系统 ，硬链接不可以</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.软链接可以对一个不存在的文件名进行链接</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4.软链接可以对目录进行链接</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 硬链接:</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.硬链接，以文件副本的形式存在。但不占用实际空间。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.不允许给目录创建硬链接</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.硬链接只有在同一个文件系统中才能创建</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 需要注意：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 第一：ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 第二：ln的链接又分软链接和硬链接两种，软链接就是ln –s 源文件 目标文件，它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接 ln 源文件 目标文件，没有参数-s， 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 第三：ln指令用在链接文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则会把前面指定的所有文件或目录复制到该目录中。若同时指定多个文件或目录，且最后的目的地并非是一个已存在的目录，则会出现错误信息。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 常用参数：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -b 删除，覆盖以前建立的链接</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -s 软链接（符号链接）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -v 显示详细处理过程</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实例：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （1）给文件创建软链接，并显示操作信息</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ln -sv source.log link.log</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （2）给文件创建硬链接，并显示操作信息</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ln -v source.log link1.log</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （3）给目录创建软链接</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ln -sv /opt/soft/test/test3 /opt/soft/test/test5</p><h1>24、date命令</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 显示或设定系统的日期与时间</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 命令参数：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -d&lt;字符串&gt; 　显示字符串所指的日期与时间。字符串前后必须加上双引号。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -s&lt;字符串&gt; 　根据字符串来设置日期与时间。字符串前后必须加上双引号。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -u 　显示GMT。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %H 小时(00-23)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %I 小时(00-12)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %M 分钟(以00-59来表示)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %s 总秒数。起算时间为1970-01-01 00:00:00 UTC。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %S 秒(以本地的惯用法来表示)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %a 星期的缩写。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %A 星期的完整名称。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %d 日期(以01-31来表示)。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %D 日期(含年月日)。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %m 月份(以01-12来表示)。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %y 年份(以00-99来表示)。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %Y 年份(以四位数来表示)。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实例：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （1）显示下一天</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; date +%Y%m%d --date=\"+1 day\"&nbsp; //显示下一天的日期</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （2）-d参数使用</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; date -d \"nov 22\"&nbsp; 今年的 11 月 22 日是星期三</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; date -d \'2 weeks\' 2周后的日期</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; date -d \'next monday\' (下周一的日期)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; date -d next-day +%Y%m%d（明天的日期）或者：date -d tomorrow +%Y%m%d</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; date -d last-day +%Y%m%d(昨天的日期) 或者：date -d yesterday +%Y%m%d</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; date -d last-month +%Y%m(上个月是几月)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; date -d next-month +%Y%m(下个月是几月)</p><h1>25、cal命令</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 可以用户显示公历（阳历）日历如只有一个参数，则表示年份(1-9999)，如有两个参数，则表示月份和年份</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 常用参数：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -3 显示前一月，当前月，后一月三个月的日历</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -m 显示星期一为第一列</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -j 显示在当前年第几天</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -y [year]显示当前年[year]份的日历</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实例：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （1）显示指定年月日期</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cal 9 2012</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （2）显示2013年每个月日历</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cal -y 2013</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （3）将星期一做为第一列,显示前中后三月</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cal -3m</p><h1>26、grep命令</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 强大的文本搜索命令，grep(Global Regular Expression Print)全局正则表达式搜索</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; grep的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 命令格式：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; grep [option] pattern file|dir</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 常用参数：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -A n --after-context显示匹配字符后n行</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -B n --before-context显示匹配字符前n行</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -C n --context 显示匹配字符前后n行</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -c --count 计算符合样式的列数</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -i 忽略大小写</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -l 只列出文件内容符合指定的样式的文件名称</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -f 从文件中读取关键词</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -n 显示匹配内容的所在文件中行数</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -R 递归查找文件夹</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; grep的规则表达式:</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^&nbsp; #锚定行的开始 如：\'^grep\'匹配所有以grep开头的行。&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $&nbsp; #锚定行的结束 如：\'grep$\'匹配所有以grep结尾的行。&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .&nbsp; #匹配一个非换行符的字符 如：\'gr.p\'匹配gr后接一个任意字符，然后是p。&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; #匹配零个或多个先前字符 如：\'*grep\'匹配所有一个或多个空格后紧跟grep的行。&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .*&nbsp;&nbsp; #一起用代表任意字符。&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; []&nbsp;&nbsp; #匹配一个指定范围内的字符，如\'[Gg]rep\'匹配Grep和grep。&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [^]&nbsp; #匹配一个不在指定范围内的字符，如：\'[^A-FH-Z]rep\'匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\(..\\)&nbsp; #标记匹配字符，如\'\\(love\\)\'，love被标记为1。&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #锚定单词的开始，如:\'\\&lt;grep\'匹配包含以grep开头的单词的行。&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #锚定单词的结束，如\'grep\\&gt;\'匹配包含以grep结尾的单词的行。&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x\\{m\\}&nbsp; #重复字符x，m次，如：\'0\\{5\\}\'匹配包含5个o的行。&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x\\{m,\\}&nbsp; #重复字符x,至少m次，如：\'o\\{5,\\}\'匹配至少有5个o的行。&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x\\{m,n\\}&nbsp; #重复字符x，至少m次，不多于n次，如：\'o\\{5,10\\}\'匹配5--10个o的行。&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\w&nbsp;&nbsp;&nbsp; #匹配文字和数字字符，也就是[A-Za-z0-9]，如：\'G\\w*p\'匹配以G后跟零个或多个文字或数字字符，然后是p。&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\W&nbsp;&nbsp;&nbsp; #\\w的反置形式，匹配一个或多个非单词字符，如点号句号等。&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\b&nbsp;&nbsp;&nbsp; #单词锁定符，如: \'\\bgrep\\b\'只匹配grep。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实例：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （1）查找指定进程</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ps -ef | grep svn</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （2）查找指定进程个数</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ps -ef | grep svn -c</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （3）从文件中读取关键词</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cat test1.txt | grep -f key.log</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （4）从文件夹中递归查找以grep开头的行，并只列出文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; grep -lR \'^grep\' /tmp</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （5）查找非x开关的行内容</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; grep \'^[^x]\' test.txt</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （6）显示包含ed或者at字符的内容行</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; grep -E \'ed|at\' test.txt</p><h1>27、wc命令</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wc(word count)功能为统计指定的文件中字节数、字数、行数，并将统计结果输出</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 命令格式：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wc [option] file..</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 命令参数：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -c 统计字节数</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -l 统计行数</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -m 统计字符数</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -w 统计词数，一个字被定义为由空白、跳格或换行字符分隔的字符串</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实例：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （1）查找文件的&nbsp; 行数 单词数 字节数 文件名</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wc text.txt 结果：7&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp; 70&nbsp;&nbsp;&nbsp;&nbsp; test.txt</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （2）统计输出结果的行数</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cat test.txt | wc -l</p><h1>28、ps命令</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ps(process status)，用来查看当前运行的进程状态，一次性查看，如果需要动态连续结果使用top</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; linux上进程有5种状态:</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1. 运行(正在运行或在运行队列中等待)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2. 中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3. 不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4. 僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5. 停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ps工具标识进程的5种状态码:</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D 不可中断 uninterruptible sleep (usually IO)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; R 运行 runnable (on run queue)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S 中断 sleeping</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T 停止 traced or stopped</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Z 僵死 a defunct (”zombie”) process</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 命令参数：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -A 显示所有进程</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a 显示所有进程</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -a 显示同一终端下所有进程</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c 显示进程真实名称</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e 显示环境变量</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f 显示进程间的关系</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r 显示当前终端运行的进程</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -aux 显示所有包含其它使用的进程</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实例：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （1）显示当前所有进程环境变量及进程间关系</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ps -ef</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （2）显示当前所有进程</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ps -A</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （3）与grep联用查找某进程</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ps -aux | grep apache</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （4）找出与 cron 与 syslog 这两个服务有关的 PID 号码</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ps aux | grep \'(cron|syslog)\'</p><h1>29、top命令</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 显示当前系统正在执行的进程的相关信息，包括进程ID、内存占用率、CPU占用率等</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 常用参数：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -c 显示完整的进程命令</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -s 保密模式</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -p &lt;进程号&gt; 指定进程显示</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -n &lt;次数&gt;循环显示次数</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实例：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （1）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; top - 14:06:23 up 70 days, 16:44,&nbsp; 2 users,&nbsp; load average: 1.25, 1.32, 1.35</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tasks: 206 total,&nbsp;&nbsp; 1 running, 205 sleeping,&nbsp;&nbsp; 0 stopped,&nbsp;&nbsp; 0 zombie</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Cpu(s):&nbsp; 5.9%us,&nbsp; 3.4%sy,&nbsp; 0.0%ni, 90.4%id,&nbsp; 0.0%wa,&nbsp; 0.0%hi,&nbsp; 0.2%si,&nbsp; 0.0%st</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Mem:&nbsp; 32949016k total, 14411180k used, 18537836k free,&nbsp;&nbsp; 169884k buffers</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Swap: 32764556k total,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0k used, 32764556k free,&nbsp; 3612636k cached</p><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; PID USER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR&nbsp; NI&nbsp; VIRT&nbsp; RES&nbsp; SHR S %CPU %MEM&nbsp;&nbsp;&nbsp; TIME+&nbsp; COMMAND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 28894 root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 22&nbsp;&nbsp; 0 1501m 405m&nbsp; 10m S 52.2&nbsp; 1.3&nbsp;&nbsp; 2534:16 java&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 前五行是当前系统情况整体的统计信息区，</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 第一行，任务队列信息，同 uptime 命令的执行结果，具体参数说明情况如下：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 14:06:23 — 当前系统时间</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; up 70 days, 16:44 — 系统已经运行了70天16小时44分钟（在这期间系统没有重启过的吆！）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 users — 当前有2个用户登录系统</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; load average: 1.15, 1.42, 1.44 — load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 第二行，Tasks — 任务（进程），具体信息说明如下：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 系统现在共有206个进程，其中处于运行中的有1个，205个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有0个。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 第三行，cpu状态信息，具体属性说明如下：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5.9%us — 用户空间占用CPU的百分比。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.4% sy — 内核空间占用CPU的百分比。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0% ni — 改变过优先级的进程占用CPU的百分比</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 90.4% id — 空闲CPU百分比</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0% wa — IO等待占用CPU的百分比</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.2% si — 软中断（Software Interrupts）占用CPU的百分比</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 备注：在这里CPU的使用比率和windows概念不同，需要理解linux系统用户空间和内核空间的相关知识！</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 第四行,内存状态，具体信息如下：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32949016k total — 物理内存总量（32GB）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 14411180k used — 使用中的内存总量（14GB）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 18537836k free — 空闲内存总量（18GB）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 169884k buffers — 缓存的内存量 （169M）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 第五行，swap交换分区信息，具体信息说明如下：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32764556k total — 交换区总量（32GB）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0k used — 使用的交换区总量（0K）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32764556k free — 空闲交换区总量（32GB）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3612636k cached — 缓冲的交换区总量（3.6GB）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 第六行，空行。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 第七行以下：各进程（任务）的状态监控，项目列信息说明如下：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PID — 进程id</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; USER — 进程所有者</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR — 进程优先级</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NI — nice值。负值表示高优先级，正值表示低优先级</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SHR — 共享内存大小，单位kb</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %CPU — 上次更新到现在的CPU时间占用百分比</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %MEM — 进程使用的物理内存百分比</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME+ — 进程使用的CPU时间总计，单位1/100秒</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COMMAND — 进程名称（命令名/命令行）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; top交互命令</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; h 显示top交互命令帮助信息</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c 切换显示命令名称和完整命令行</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m 以内存使用率排序</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P 根据CPU使用百分比大小进行排序</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T 根据时间/累计时间进行排序</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; W 将当前设置写入~/.toprc文件中</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; o或者O 改变显示项目的顺序</p><h1>30、kill命令</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 发送指定的信号到相应进程。不指定型号将发送SIGTERM（15）终止指定进程。如果任无法终止该程序可用“-KILL” 参数，其发送的信号为SIGKILL(9) ，将强制结束进程，使用ps命令或者jobs 命令可以查看进程号。root用户将影响用户的进程，非root用户只能影响自己的进程。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 常用参数：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -l&nbsp; 信号，若果不加信号的编号参数，则使用“-l”参数会列出全部的信号名称</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -a&nbsp; 当处理当前进程时，不限制命令名和进程号的对应关系</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -p&nbsp; 指定kill 命令只打印相关进程的进程号，而不发送任何信号</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -s&nbsp; 指定发送信号</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -u&nbsp; 指定用户</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实例：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （1）先使用ps查找进程pro1，然后用kill杀掉</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kill -9 $(ps -ef | grep pro1)</p><h1>31、free命令</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 显示系统内存使用情况，包括物理内存、交互区内存(swap)和内核缓冲区内存。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 命令参数：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -b 以Byte显示内存使用情况</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -k 以kb为单位显示内存使用情况</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -m 以mb为单位显示内存使用情况</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -g 以gb为单位显示内存使用情况</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -s&lt;间隔秒数&gt; 持续显示内存</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -t 显示内存使用总合</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实例：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （1）显示内存使用情况</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free -k</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free -m</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （2）以总和的形式显示内存的使用信息</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free -t</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （3）周期性查询内存使用情况</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free -s 10</p>', 2, 0, 0, 1, 1, 1, '2019-04-21 16:26:51', '2019-04-21 16:26:51');
INSERT INTO `article` VALUES (44, 1, 'vue的双向绑定原理及实现', '<h1 id=\"vue的双向绑定原理及实现-前言\"><strong>前言</strong></h1><p>使用vue也好有一段时间了，虽然对其双向绑定原理也有了解个大概，但也没好好探究下其原理实现，所以这次特意花了几晚时间查阅资料和阅读相关源码，自己也实现一个简单版vue的双向绑定版本，先上个成果图来吸引各位：</p><p>代码： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;效果图：</p><p><img src=\"https://images2015.cnblogs.com/blog/938664/201705/938664-20170522223732179-2029881767.png\"><img src=\"https://images2015.cnblogs.com/blog/938664/201705/938664-20170522224049413-1823976084.gif\"></p><p>是不是看起来跟vue的使用方式差不多？接下来就来从原理到实现，从简到难一步一步来实现这个SelfVue。由于本文只是为了学习和分享，所以只是简单实现下原理，并没有考虑太多情况和设计，如果大家有什么建议，欢迎提出来。</p><p>本文主要介绍两大内容：</p><p>1. vue数据双向绑定的原理。</p><p>2. 实现简单版vue的过程，主要实现{{}}、v-model和事件指令的功能。</p><p>相关代码地址：<a class=\"external-link\" href=\"https://github.com/canfoo/self-vue\" rel=\"nofollow\">https://github.com/canfoo/self-vue</a></p><h1 id=\"vue的双向绑定原理及实现-vue数据双向绑定方法\"><strong>vue数据双向绑定原理</strong></h1><p>vue数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的，我们可以先来看一下通过控制台输出一个定义在vue初始化数据上的对象是个什么东西。</p><p>代码：</p><div class=\"cnblogs_code\"><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div><pre>var vm = new Vue({\r\n    data: {\r\n        obj: {\r\n            a: 1\r\n        }\r\n    },\r\n    created: function () {\r\n        console.log(this.obj);\r\n    }\r\n});</pre><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div></div><p>结果：</p><p><img src=\"https://images2015.cnblogs.com/blog/938664/201705/938664-20170522225032257-1498304708.png\"></p><p>我们可以看到属性a有两个相对应的get和set方法，为什么会多出这两个方法呢？因为vue是通过Object.defineProperty()来实现数据劫持的。</p><p>Object.defineProperty( )是用来做什么的？它可以来控制一个对象属性的一些特有操作，比如读写权、是否可以枚举，这里我们主要先来研究下它对应的两个描述属性get和set，如果还不熟悉其用法，<a class=\"external-link\" href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\" rel=\"nofollow\">请点击这里阅读更多用法</a>。</p><p>在平常，我们很容易就可以打印出一个对象的属性数据：</p><div class=\"cnblogs_code\"><pre>var Book = {\r\n  name: \'vue权威指南\'\r\n};\r\nconsole.log(Book.name);  // vue权威指南</pre></div><p>如果想要在执行console.log(book.name)的同时，直接给书名加个书名号，那要怎么处理呢？或者说要通过什么监听对象 Book 的属性值。这时候Object.defineProperty( )就派上用场了，代码如下：</p><div class=\"cnblogs_code\"><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div><pre>var Book = {}\r\nvar name = \'\';\r\nObject.defineProperty(Book, \'name\', {\r\n  set: function (value) {\r\n    name = value;\r\n    console.log(\'你取了一个书名叫做\' + value);\r\n  },\r\n  get: function () {\r\n    return \'《\' + name + \'》\'\r\n  }\r\n})\r\n \r\nBook.name = \'vue权威指南\';  // 你取了一个书名叫做vue权威指南\r\nconsole.log(Book.name);  // 《vue权威指南》</pre><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div></div><p>我们通过Object.defineProperty( )设置了对象Book的name属性，对其get和set进行重写操作，顾名思义，get就是在读取name属性这个值触发的函数，set就是在设置name属性这个值触发的函数，所以当执行&nbsp;Book.name = \'vue权威指南\' 这个语句时，控制台会打印出 \"你取了一个书名叫做vue权威指南\"，紧接着，当读取这个属性时，就会输出 \"《vue权威指南》\"，因为我们在get函数里面对该值做了加工了。如果这个时候我们执行下下面的语句，控制台会输出什么？</p><div class=\"cnblogs_code\"><pre>console.log(Book);</pre></div><p>结果：</p><p><img src=\"https://images2015.cnblogs.com/blog/938664/201705/938664-20170522225238960-1133794938.png\"></p><p>乍一看，是不是跟我们在上面打印vue数据长得有点类似，说明vue确实是通过这种方法来进行数据劫持的。接下来我们通过其原理来实现一个简单版的mvvm双向绑定代码。</p><h1 id=\"vue的双向绑定原理及实现-思路分析\"><strong>思路分析</strong></h1><p>实现mvvm主要包含两个方面，数据变化更新视图，视图变化更新数据：</p><p><img src=\"https://images2015.cnblogs.com/blog/938664/201705/938664-20170522225407945-723348101.jpg\"></p><p>事件就可以实现了。所以我们着重来分析下，当数据改变，如何更新视图的。</p><p>数据更新视图的重点是如何知道数据变了，只要知道数据变了，那么接下去的事都好处理。如何知道数据变了，其实上文我们已经给出答案了，就是通过Object.defineProperty( )对属性设置一个set函数，当数据改变了就会来触发这个函数，所以我们只要将一些需要更新的方法放在这里面就可以实现data更新view了。</p><p><img src=\"https://images2015.cnblogs.com/blog/938664/201705/938664-20170522230647382-1643499691.jpg\"></p><p>思路有了，接下去就是实现过程了。</p><h1 id=\"vue的双向绑定原理及实现-实现过程\"><strong>实现过程</strong></h1><p>我们已经知道实现数据的双向绑定，首先要对数据进行劫持监听，所以我们需要设置一个监听器Observer，用来监听所有属性。如果属性发上变化了，就需要告诉订阅者Watcher看是否需要更新。因为订阅者是有很多个，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理的。接着，我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数，此时当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。因此接下去我们执行以下3个步骤，实现数据的双向绑定：</p><p>1.实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。</p><p>2.实现一个订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。</p><p>3.实现一个解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。</p><p>流程图如下：</p><p><img src=\"https://images2015.cnblogs.com/blog/938664/201705/938664-20170522225458132-1434604303.png\"></p><h2 id=\"vue的双向绑定原理及实现-1.实现一个Observer\"><strong>1.实现一个Observer</strong></h2><p>Observer是一个数据监听器，其实现核心方法就是前文所说的Object.defineProperty( )。如果要对所有属性都进行监听的话，那么可以通过递归方法遍历所有属性值，并对其进行Object.defineProperty( )处理。如下代码，实现了一个Observer。</p><div class=\"cnblogs_code\"><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div><pre>function defineReactive(data, key, val) {\r\n    observe(val); // 递归遍历所有子属性\r\n    Object.defineProperty(data, key, {\r\n        enumerable: true,\r\n        configurable: true,\r\n        get: function() {\r\n            return val;\r\n        },\r\n        set: function(newVal) {\r\n            val = newVal;\r\n            console.log(\'属性\' + key + \'已经被监听了，现在值为：“\' + newVal.toString() + \'”\');\r\n        }\r\n    });\r\n}\r\n \r\nfunction observe(data) {\r\n    if (!data || typeof data !== \'object\') {\r\n        return;\r\n    }\r\n    Object.keys(data).forEach(function(key) {\r\n        defineReactive(data, key, data[key]);\r\n    });\r\n};\r\n \r\nvar library = {\r\n    book1: {\r\n        name: \'\'\r\n    },\r\n    book2: \'\'\r\n};\r\nobserve(library);\r\nlibrary.book1.name = \'vue权威指南\'; // 属性name已经被监听了，现在值为：“vue权威指南”\r\nlibrary.book2 = \'没有此书籍\';  // 属性book2已经被监听了，现在值为：“没有此书籍”</pre><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div></div><p>思路分析中，需要创建一个可以容纳订阅者的消息订阅器Dep，订阅器Dep主要负责收集订阅者，然后再属性变化的时候执行对应订阅者的更新函数。所以显然订阅器需要有一个容器，这个容器就是list，将上面的Observer稍微改造下，植入消息订阅器：</p><div class=\"cnblogs_code\"><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div><pre>function defineReactive(data, key, val) {\r\n    observe(val); // 递归遍历所有子属性\r\n    var dep = new Dep(); \r\n    Object.defineProperty(data, key, {\r\n        enumerable: true,\r\n        configurable: true,\r\n        get: function() {\r\n            if (是否需要添加订阅者) {\r\n                dep.addSub(watcher); // 在这里添加一个订阅者\r\n            }\r\n            return val;\r\n        },\r\n        set: function(newVal) {\r\n            if (val === newVal) {\r\n                return;\r\n            }\r\n            val = newVal;\r\n            console.log(\'属性\' + key + \'已经被监听了，现在值为：“\' + newVal.toString() + \'”\');\r\n            dep.notify(); // 如果数据变化，通知所有订阅者\r\n        }\r\n    });\r\n}\r\n \r\nfunction Dep () {\r\n    this.subs = [];\r\n}\r\nDep.prototype = {\r\n    addSub: function(sub) {\r\n        this.subs.push(sub);\r\n    },\r\n    notify: function() {\r\n        this.subs.forEach(function(sub) {\r\n            sub.update();\r\n        });\r\n    }\r\n};</pre><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div></div><p>从代码上看，我们将订阅器Dep添加一个订阅者设计在getter里面，这是为了让Watcher初始化进行触发，因此需要判断是否要添加订阅者，至于具体设计方案，下文会详细说明的。在setter函数里面，如果数据变化，就会去通知所有订阅者，订阅者们就会去执行对应的更新的函数。到此为止，一个比较完整Observer已经实现了，接下来我们开始设计Watcher。</p><h2 id=\"vue的双向绑定原理及实现-2.实现Watcher\"><strong>2.实现Watcher</strong></h2><p>订阅者Watcher在初始化的时候需要将自己添加进订阅器Dep中，那该如何添加呢？我们已经知道监听器Observer是在get函数执行了添加订阅者Wather的操作的，所以我们只要在订阅者Watcher初始化的时候触发对应的get函数去执行添加订阅者操作即可，那要如何触发get的函数，再简单不过了，只要获取对应的属性值就可以触发了，核心原因就是因为我们使用了Object.defineProperty( )进行数据监听。这里还有一个细节点需要处理，我们只要在订阅者Watcher初始化的时候才需要添加订阅者，所以需要做一个判断操作，因此可以在订阅器上做一下手脚：在Dep.target上缓存下订阅者，添加成功后再将其去掉就可以了。订阅者Watcher的实现如下：</p><div class=\"cnblogs_code\"><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div><pre>function Watcher(vm, exp, cb) {\r\n    this.cb = cb;\r\n    this.vm = vm;\r\n    this.exp = exp;\r\n    this.value = this.get();  // 将自己添加到订阅器的操作\r\n}\r\n \r\nWatcher.prototype = {\r\n    update: function() {\r\n        this.run();\r\n    },\r\n    run: function() {\r\n        var value = this.vm.data[this.exp];\r\n        var oldVal = this.value;\r\n        if (value !== oldVal) {\r\n            this.value = value;\r\n            this.cb.call(this.vm, value, oldVal);\r\n        }\r\n    },\r\n    get: function() {\r\n        Dep.target = this;  // 缓存自己\r\n        var value = this.vm.data[this.exp]  // 强制执行监听器里的get函数\r\n        Dep.target = null;  // 释放自己\r\n        return value;\r\n    }\r\n};</pre><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div></div><p>这时候，我们需要对监听器Observer也做个稍微调整，主要是对应Watcher类原型上的get函数。需要调整地方在于defineReactive函数：</p><div class=\"cnblogs_code\"><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div><pre>function defineReactive(data, key, val) {\r\n    observe(val); // 递归遍历所有子属性\r\n    var dep = new Dep(); \r\n    Object.defineProperty(data, key, {\r\n        enumerable: true,\r\n        configurable: true,\r\n        get: function() {\r\n            if (Dep.target) {.  // 判断是否需要添加订阅者\r\n                dep.addSub(Dep.target); // 在这里添加一个订阅者\r\n            }\r\n            return val;\r\n        },\r\n        set: function(newVal) {\r\n            if (val === newVal) {\r\n                return;\r\n            }\r\n            val = newVal;\r\n            console.log(\'属性\' + key + \'已经被监听了，现在值为：“\' + newVal.toString() + \'”\');\r\n            dep.notify(); // 如果数据变化，通知所有订阅者\r\n        }\r\n    });\r\n}\r\nDep.target = null;</pre><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div></div><p>到此为止，简单版的Watcher设计完毕，这时候我们只要将Observer和Watcher关联起来，就可以实现一个简单的双向绑定数据了。因为这里没有还没有设计解析器Compile，所以对于模板数据我们都进行写死处理，假设模板上又一个节点，且id号为\'name\'，并且双向绑定的绑定的变量也为\'name\'，且是通过两个大双括号包起来（这里只是为了演示，暂时没什么用处），模板如下：</p><div class=\"cnblogs_code\"><pre>    <h1 id=\"name\">{{name}}</h1>\r\n</pre></div><p>这时候我们需要将Observer和Watcher关联起来：</p><div class=\"cnblogs_code\"><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div><pre>function SelfVue (data, el, exp) {\r\n    this.data = data;\r\n    observe(data);\r\n    el.innerHTML = this.data[exp];  // 初始化模板数据的值\r\n    new Watcher(this, exp, function (value) {\r\n        el.innerHTML = value;\r\n    });\r\n    return this;\r\n}</pre><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div></div><p>然后在页面上new以下SelfVue类，就可以实现数据的双向绑定了：</p><div class=\"cnblogs_code\"><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div><pre>    <h1 id=\"name\">{{name}}</h1>\r\n\r\n\r\n\r\n\r\n</pre><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div></div><p>这时候打开页面，可以看到页面刚开始显示了是\'hello world\'，过了2s后就变成\'canfoo\'了。到这里，总算大功告成一半了，但是还有一个细节问题，我们在赋值的时候是这样的形式 \' &nbsp;selfVue.data.name = \'canfoo\' &nbsp;\' 而我们理想的形式是\' &nbsp;selfVue.name = \'canfoo\' &nbsp;\'为了实现这样的形式，我们需要在new SelfVue的时候做一个代理处理，让访问selfVue的属性代理为访问selfVue.data的属性，实现原理还是使用Object.defineProperty( )对属性值再包一层：</p><div class=\"cnblogs_code\"><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div><pre>function SelfVue (data, el, exp) {\r\n    var self = this;\r\n    this.data = data;\r\n \r\n    Object.keys(data).forEach(function(key) {\r\n        self.proxyKeys(key);  // 绑定代理属性\r\n    });\r\n \r\n    observe(data);\r\n    el.innerHTML = this.data[exp];  // 初始化模板数据的值\r\n    new Watcher(this, exp, function (value) {\r\n        el.innerHTML = value;\r\n    });\r\n    return this;\r\n}\r\n \r\nSelfVue.prototype = {\r\n    proxyKeys: function (key) {\r\n        var self = this;\r\n        Object.defineProperty(this, key, {\r\n            enumerable: false,\r\n            configurable: true,\r\n            get: function proxyGetter() {\r\n                return self.data[key];\r\n            },\r\n            set: function proxySetter(newVal) {\r\n                self.data[key] = newVal;\r\n            }\r\n        });\r\n    }\r\n}</pre><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div></div><p>这下我们就可以直接通过\' &nbsp;selfVue.name = \'canfoo\' &nbsp;\'的形式来进行改变模板数据了。如果想要迫切看到现象的童鞋赶快来<a class=\"external-link\" href=\"https://github.com/canfoo/self-vue/tree/master/v1\" rel=\"nofollow\">获取代码！</a></p><h2 id=\"vue的双向绑定原理及实现-3.实现Compile\"><strong>3.实现Compile</strong></h2><p>虽然上面已经实现了一个双向数据绑定的例子，但是整个过程都没有去解析dom节点，而是直接固定某个节点进行替换数据的，所以接下来需要实现一个解析器Compile来做解析和绑定工作。解析器Compile实现步骤：</p><p>1.解析模板指令，并替换模板数据，初始化视图</p><p>2.将模板指令对应的节点绑定对应的更新函数，初始化相应的订阅器</p><p>为了解析模板，首先需要获取到dom元素，然后对含有dom元素上含有指令的节点进行处理，因此这个环节需要对dom操作比较频繁，所有可以先建一个fragment片段，将需要解析的dom节点存入fragment片段里再进行处理：</p><div class=\"cnblogs_code\"><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div><pre>function nodeToFragment (el) {\r\n    var fragment = document.createDocumentFragment();\r\n    var child = el.firstChild;\r\n    while (child) {\r\n        // 将Dom元素移入fragment中\r\n        fragment.appendChild(child);\r\n        child = el.firstChild\r\n    }\r\n    return fragment;\r\n}</pre><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div></div><p>接下来需要遍历各个节点，对含有相关指定的节点进行特殊处理，这里咱们先处理最简单的情况，只对带有 \'{{变量}}\' 这种形式的指令进行处理，先简道难嘛，后面再考虑更多指令情况：</p><div class=\"cnblogs_code\"><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div><pre>function compileElement (el) {\r\n    var childNodes = el.childNodes;\r\n    var self = this;\r\n    [].slice.call(childNodes).forEach(function(node) {\r\n        var reg = /\\{\\{(.*)\\}\\}/;\r\n        var text = node.textContent;\r\n \r\n        if (self.isTextNode(node) &amp;&amp; reg.test(text)) {  // 判断是否是符合这种形式{{}}的指令\r\n            self.compileText(node, reg.exec(text)[1]);\r\n        }\r\n \r\n        if (node.childNodes &amp;&amp; node.childNodes.length) {\r\n            self.compileElement(node);  // 继续递归遍历子节点\r\n        }\r\n    });\r\n},\r\nfunction compileText (node, exp) {\r\n    var self = this;\r\n    var initText = this.vm[exp];\r\n    updateText(node, initText);  // 将初始化的数据初始化到视图中\r\n    new Watcher(this.vm, exp, function (value) {  // 生成订阅器并绑定更新函数\r\n        self.updateText(node, value);\r\n    });\r\n},\r\nfunction updateText (node, value) {\r\n    node.textContent = typeof value == \'undefined\' ? \'\' : value;\r\n}</pre><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div></div><p>获取到最外层节点后，调用compileElement函数，对所有子节点进行判断，如果节点是文本节点且匹配{{}}这种形式指令的节点就开始进行编译处理，编译处理首先需要初始化视图数据，对应上面所说的步骤1，接下去需要生成一个并绑定更新函数的订阅器，对应上面所说的步骤2。这样就完成指令的解析、初始化、编译三个过程，一个解析器Compile也就可以正常的工作了。为了将解析器Compile与监听器Observer和订阅者Watcher关联起来，我们需要再修改一下类SelfVue函数：</p><div class=\"cnblogs_code\"><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div><pre>function SelfVue (options) {\r\n    var self = this;\r\n    this.vm = this;\r\n    this.data = options;\r\n \r\n    Object.keys(this.data).forEach(function(key) {\r\n        self.proxyKeys(key);\r\n    });\r\n \r\n    observe(this.data);\r\n    new Compile(options, this.vm);\r\n    return this;\r\n}</pre><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div></div><div class=\"code panel pdl conf-macro output-block\" data-hasbody=\"true\" data-macro-name=\"code\"><div class=\"codeContent panelContent pdl\"><div id=\"highlighter_436064\" class=\"syntaxhighlighter sh-confluence nogutter  js\">更改后，我们就不要像之前通过传入固定的元素值进行双向绑定了，可以随便命名各种变量进行双向绑定了：</div></div></div><div class=\"cnblogs_code\"><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div><pre>    <div id=\"app\">\r\n        <h2>{{title}}</h2>\r\n        <h1>{{name}}</h1>\r\n    </div>\r\n\r\n\r\n\r\n\r\n\r\n</pre><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div></div><p>如上代码，在页面上可观察到，刚开始titile和name分别被初始化为 \'hello world\' 和空，2s后title被替换成 \'你好\' 3s后name被替换成 \'canfoo\' 了。废话不多说，再给你们来一个这个版本的代码（v2），<a class=\"external-link\" href=\"https://github.com/canfoo/self-vue/tree/master/v2\" rel=\"nofollow\">获取代码！</a></p><p>到这里，一个数据双向绑定功能已经基本完成了，接下去就是需要完善更多指令的解析编译，在哪里进行更多指令的处理呢？答案很明显，只要在上文说的compileElement函数加上对其他指令节点进行判断，然后遍历其所有属性，看是否有匹配的指令的属性，如果有的话，就对其进行解析编译。这里我们再添加一个v-model指令和事件指令的解析编译，对于这些节点我们使用函数compile进行解析处理：</p><div class=\"cnblogs_code\"><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div><pre>function compile (node) {\r\n    var nodeAttrs = node.attributes;\r\n    var self = this;\r\n    Array.prototype.forEach.call(nodeAttrs, function(attr) {\r\n        var attrName = attr.name;\r\n        if (self.isDirective(attrName)) {\r\n            var exp = attr.value;\r\n            var dir = attrName.substring(2);\r\n            if (self.isEventDirective(dir)) {  // 事件指令\r\n                self.compileEvent(node, self.vm, exp, dir);\r\n            } else {  // v-model 指令\r\n                self.compileModel(node, self.vm, exp, dir);\r\n            }\r\n            node.removeAttribute(attrName);\r\n        }\r\n    });\r\n}</pre><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div></div><p>上面的compile函数是挂载Compile原型上的，它首先遍历所有节点属性，然后再判断属性是否是指令属性，如果是的话再区分是哪种指令，再进行相应的处理，处理方法相对来说比较简单，这里就不再列出来，想要马上看阅读代码的同学可以马上<a class=\"external-link\" href=\"https://github.com/canfoo/self-vue/tree/master/v3\" rel=\"nofollow\">点击这里获取。</a></p><p>最后我们在稍微改造下类SelfVue，使它更像vue的用法：</p><div class=\"cnblogs_code\"><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div><pre>function SelfVue (options) {\r\n    var self = this;\r\n    this.data = options.data;\r\n    this.methods = options.methods;\r\n \r\n    Object.keys(this.data).forEach(function(key) {\r\n        self.proxyKeys(key);\r\n    });\r\n \r\n    observe(this.data);\r\n    new Compile(options.el, this);\r\n    options.mounted.call(this); // 所有事情处理好后执行mounted函数\r\n}</pre><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div></div><p>这时候我们可以来真正测试了，在页面上设置如下东西：</p><div class=\"cnblogs_code\"><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div><pre>    <div id=\"app\">\r\n        <h2>{{title}}</h2>\r\n        <input v-model=\"name\">\r\n        <h1>{{name}}</h1>\r\n        <button v-on:click=\"clickMe\">click me!</button>\r\n    </div>\r\n\r\n\r\n\r\n\r\n\r\n</pre><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a title=\"复制代码\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div></div><p>是不是看起来跟vue的使用方法一样，哈，真正的大功告成！想要代码，直接<a class=\"external-link\" href=\"https://github.com/canfoo/self-vue/tree/master/v3\" rel=\"nofollow\">点击这里获取！</a>现象还没描述？直接上图！！！请观赏</p><p><img src=\"https://images2015.cnblogs.com/blog/938664/201705/938664-20170522230153054-1986692570.gif\"></p><p>其实这个效果图，就是本文开头贴出来的效果图了，前文说着要带着大家实现，所以就在这里把图再贴一次了，这叫首尾呼应嘛。</p><p>最后希望本文对你有帮助，如果有问题请留言一起探讨。</p>', 0, 0, 0, 1, 1, 1, '2019-04-21 16:29:30', '2019-04-21 16:29:04');

-- ----------------------------
-- Table structure for article_category_ref
-- ----------------------------
DROP TABLE IF EXISTS `article_category_ref`;
CREATE TABLE `article_category_ref`  (
  `article_id` int(11) NULL DEFAULT NULL,
  `category_id` int(11) NULL DEFAULT NULL
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of article_category_ref
-- ----------------------------
INSERT INTO `article_category_ref` VALUES (36, 11);
INSERT INTO `article_category_ref` VALUES (36, 15);
INSERT INTO `article_category_ref` VALUES (37, 5);
INSERT INTO `article_category_ref` VALUES (37, 7);
INSERT INTO `article_category_ref` VALUES (38, 17);
INSERT INTO `article_category_ref` VALUES (38, 21);
INSERT INTO `article_category_ref` VALUES (40, 5);
INSERT INTO `article_category_ref` VALUES (40, 6);
INSERT INTO `article_category_ref` VALUES (41, 17);
INSERT INTO `article_category_ref` VALUES (41, 20);
INSERT INTO `article_category_ref` VALUES (42, 1);
INSERT INTO `article_category_ref` VALUES (42, 4);
INSERT INTO `article_category_ref` VALUES (43, 17);
INSERT INTO `article_category_ref` VALUES (43, 19);
INSERT INTO `article_category_ref` VALUES (44, 1);
INSERT INTO `article_category_ref` VALUES (44, 4);
INSERT INTO `article_category_ref` VALUES (45, 5);
INSERT INTO `article_category_ref` VALUES (45, 6);
INSERT INTO `article_category_ref` VALUES (47, 5);
INSERT INTO `article_category_ref` VALUES (47, 6);
INSERT INTO `article_category_ref` VALUES (46, 23);
INSERT INTO `article_category_ref` VALUES (46, 24);

-- ----------------------------
-- Table structure for article_tag_ref
-- ----------------------------
DROP TABLE IF EXISTS `article_tag_ref`;
CREATE TABLE `article_tag_ref`  (
  `article_id` int(11) NOT NULL,
  `tag_id` int(11) NOT NULL,
  PRIMARY KEY (`article_id`, `tag_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of article_tag_ref
-- ----------------------------
INSERT INTO `article_tag_ref` VALUES (36, 3);
INSERT INTO `article_tag_ref` VALUES (36, 20);
INSERT INTO `article_tag_ref` VALUES (37, 3);
INSERT INTO `article_tag_ref` VALUES (38, 6);
INSERT INTO `article_tag_ref` VALUES (38, 26);
INSERT INTO `article_tag_ref` VALUES (40, 6);
INSERT INTO `article_tag_ref` VALUES (40, 7);
INSERT INTO `article_tag_ref` VALUES (40, 33);
INSERT INTO `article_tag_ref` VALUES (41, 23);
INSERT INTO `article_tag_ref` VALUES (42, 3);
INSERT INTO `article_tag_ref` VALUES (42, 20);
INSERT INTO `article_tag_ref` VALUES (43, 17);
INSERT INTO `article_tag_ref` VALUES (43, 19);
INSERT INTO `article_tag_ref` VALUES (44, 3);
INSERT INTO `article_tag_ref` VALUES (45, 6);
INSERT INTO `article_tag_ref` VALUES (47, 6);

-- ----------------------------
-- Table structure for category
-- ----------------------------
DROP TABLE IF EXISTS `category`;
CREATE TABLE `category`  (
  `category_id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,
  `category_pid` int(11) NULL DEFAULT NULL,
  `category_name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `category_description` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `category_order` int(11) UNSIGNED NULL DEFAULT 1,
  `category_icon` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`category_id`) USING BTREE,
  UNIQUE INDEX `category_name`(`category_name`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 25 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of category
-- ----------------------------
INSERT INTO `category` VALUES (1, 0, 'Web前端', 'Web前端', 1, 'fa fa-coffee');
INSERT INTO `category` VALUES (2, 1, 'HTML/CSS', NULL, 1, NULL);
INSERT INTO `category` VALUES (3, 1, 'JavaScript', NULL, 1, NULL);
INSERT INTO `category` VALUES (4, 1, '前端框架', NULL, 1, NULL);
INSERT INTO `category` VALUES (5, 0, '编程语言', '编程语言', 1, 'fa fa-code');
INSERT INTO `category` VALUES (6, 5, 'Java', NULL, 1, NULL);
INSERT INTO `category` VALUES (7, 5, 'Python', NULL, 1, NULL);
INSERT INTO `category` VALUES (8, 5, 'C语言', NULL, 1, NULL);
INSERT INTO `category` VALUES (9, 5, 'C++', NULL, 1, NULL);
INSERT INTO `category` VALUES (10, 5, '其它语言', NULL, 1, NULL);
INSERT INTO `category` VALUES (11, 0, '数据库技术', NULL, 1, 'fa fa-database');
INSERT INTO `category` VALUES (12, 11, 'MySQL', NULL, 1, NULL);
INSERT INTO `category` VALUES (13, 11, 'Oracle', NULL, 1, NULL);
INSERT INTO `category` VALUES (14, 11, 'SQL Server', NULL, 1, NULL);
INSERT INTO `category` VALUES (15, 11, 'Redis', NULL, 1, NULL);
INSERT INTO `category` VALUES (16, 11, '其它数据库', NULL, 1, NULL);
INSERT INTO `category` VALUES (17, 0, '其它技术', NULL, 1, 'fa fa-cubes');
INSERT INTO `category` VALUES (18, 17, '数据结构与算法', NULL, 1, NULL);
INSERT INTO `category` VALUES (19, 17, '操作系统', NULL, 1, NULL);
INSERT INTO `category` VALUES (20, 17, '计算机网络', NULL, 1, NULL);
INSERT INTO `category` VALUES (21, 17, '开发工具', NULL, 1, NULL);
INSERT INTO `category` VALUES (22, 17, '其它', NULL, 1, NULL);
INSERT INTO `category` VALUES (23, 0, '闲来笔谈', NULL, 1, 'fa fa-comments');
INSERT INTO `category` VALUES (24, 23, '杂文', NULL, 1, NULL);

-- ----------------------------
-- Table structure for comment
-- ----------------------------
DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment`  (
  `comment_id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,
  `comment_pid` int(11) UNSIGNED NULL DEFAULT 0,
  `comment_pname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `comment_article_id` int(11) UNSIGNED NULL DEFAULT NULL,
  `comment_author_name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `comment_author_email` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `comment_author_url` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `comment_author_avatar` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `comment_content` varchar(1000) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `comment_agent` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `comment_ip` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `comment_create_time` datetime(0) NULL DEFAULT NULL,
  `comment_role` int(1) NULL DEFAULT NULL,
  PRIMARY KEY (`comment_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 8 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of comment
-- ----------------------------
INSERT INTO `comment` VALUES (1, 0, '', 45, '灯下黑', 'twl19970606@163.com', NULL, '/img/avatar.jpg', '不错，不错！！', NULL, '0:0:0:0:0:0:0:1', '2019-04-21 16:40:36', 0);
INSERT INTO `comment` VALUES (2, 0, '', 40, '灯下黑', 'twl19970606@163.com', NULL, '/img/avatar.jpg', '在此一游。。。', NULL, '0:0:0:0:0:0:0:1', '2019-04-21 18:06:28', 0);
INSERT INTO `comment` VALUES (3, 0, '', 41, '灯下黑', 'twl19970606@163.com', NULL, '/img/avatar.jpg', '值得学习。', NULL, '0:0:0:0:0:0:0:1', '2019-04-21 18:07:23', 0);
INSERT INTO `comment` VALUES (4, 0, '', 47, '困坐南山下', '1397213866@qq.com', NULL, '/img/avatar.jpg', 'hahaha......', NULL, '0:0:0:0:0:0:0:1', '2019-04-23 10:22:00', 0);
INSERT INTO `comment` VALUES (5, 4, '困坐南山下', 47, '困坐南山下', '1397213866@qq.com', NULL, '/img/avatar.jpg', '你好！', NULL, '0:0:0:0:0:0:0:1', '2019-04-23 10:22:16', 0);
INSERT INTO `comment` VALUES (6, 0, '', 47, '困坐南山下', '1397213866@qq.com', NULL, '/img/avatar.jpg', '世界这么大，我想去看看！', NULL, '0:0:0:0:0:0:0:1', '2019-04-23 10:22:49', 0);
INSERT INTO `comment` VALUES (7, 0, '', 47, '飞鸟', '909028627@qq.com', '', '/uploads/2019\\4/pp.jpg', '大家好！！', NULL, '0:0:0:0:0:0:0:1', '2019-04-24 11:44:07', 1);

-- ----------------------------
-- Table structure for link
-- ----------------------------
DROP TABLE IF EXISTS `link`;
CREATE TABLE `link`  (
  `link_id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,
  `link_url` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `link_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `link_image` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `link_description` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `link_owner_nickname` varchar(40) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `link_owner_contact` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `link_update_time` datetime(0) NULL DEFAULT NULL,
  `link_create_time` datetime(0) NULL DEFAULT NULL,
  `link_order` int(2) UNSIGNED NULL DEFAULT 1,
  `link_status` int(1) UNSIGNED NULL DEFAULT 1,
  PRIMARY KEY (`link_id`) USING BTREE,
  UNIQUE INDEX `link_name`(`link_name`) USING BTREE
) ENGINE = MyISAM AUTO_INCREMENT = 10 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of link
-- ----------------------------
INSERT INTO `link` VALUES (1, 'https://github.com/', 'GitHub', NULL, 'GitHub', NULL, '', '2019-04-07 16:51:03', '2019-04-07 16:29:35', 1, 1);
INSERT INTO `link` VALUES (3, 'https://www.csdn.net/', 'CSDN', NULL, 'CSDN', NULL, NULL, '2019-04-13 18:24:52', '2019-04-13 18:24:55', 1, 1);
INSERT INTO `link` VALUES (2, 'https://www.infoq.cn/', 'InfoQ', NULL, 'InfoQ', NULL, '', '2019-01-01 15:03:26', '2019-02-01 16:51:49', 1, 1);
INSERT INTO `link` VALUES (4, 'https://www.baidu.com/', '百度', NULL, '百度', NULL, NULL, '2019-04-13 18:26:05', '2019-04-13 18:26:08', 1, 1);
INSERT INTO `link` VALUES (5, 'https:ny.chenji.site', '宸极新闻', NULL, '宸极新闻', NULL, NULL, '2019-04-13 18:29:31', '2019-04-13 18:29:33', 1, 1);
INSERT INTO `link` VALUES (9, 'https://www.nowcoder.com/', '牛客网', NULL, '牛牛牛', NULL, '', '2019-04-24 17:44:17', '2019-04-24 17:44:17', NULL, 0);

-- ----------------------------
-- Table structure for menu
-- ----------------------------
DROP TABLE IF EXISTS `menu`;
CREATE TABLE `menu`  (
  `menu_id` int(11) NOT NULL AUTO_INCREMENT,
  `menu_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `menu_url` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `menu_level` int(11) NULL DEFAULT NULL,
  `menu_icon` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `menu_order` int(11) NULL DEFAULT NULL,
  PRIMARY KEY (`menu_id`) USING BTREE,
  UNIQUE INDEX `menu_name`(`menu_name`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 6 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of menu
-- ----------------------------
INSERT INTO `menu` VALUES (3, '关于本站', '/aboutSite', 1, 'fa fa-info', 1);
INSERT INTO `menu` VALUES (4, '文章归档', '/articleFile', 1, 'fa-list-alt fa', 2);
INSERT INTO `menu` VALUES (5, '申请友链', '/applyLink', 1, 'fa fa-link', 3);

-- ----------------------------
-- Table structure for notice
-- ----------------------------
DROP TABLE IF EXISTS `notice`;
CREATE TABLE `notice`  (
  `notice_id` int(11) NOT NULL AUTO_INCREMENT,
  `notice_title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `notice_content` varchar(10000) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `notice_create_time` datetime(0) NULL DEFAULT NULL,
  `notice_update_time` datetime(0) NULL DEFAULT NULL,
  `notice_status` int(1) UNSIGNED NULL DEFAULT 1,
  `notice_order` int(2) NULL DEFAULT NULL,
  PRIMARY KEY (`notice_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 6 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of notice
-- ----------------------------
INSERT INTO `notice` VALUES (4, '最新公告！！！', '飞鸟博客即将上线', '2019-04-15 12:34:28', '2019-04-15 12:34:43', 1, 1);
INSERT INTO `notice` VALUES (5, '今日头条——', '。。。', '2019-04-15 12:49:50', '2019-04-15 12:49:50', 1, 1);

-- ----------------------------
-- Table structure for options
-- ----------------------------
DROP TABLE IF EXISTS `options`;
CREATE TABLE `options`  (
  `option_id` int(11) NOT NULL,
  `option_site_title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `option_site_descrption` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `option_meta_descrption` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `option_meta_keyword` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `option_aboutsite_avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `option_aboutsite_title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `option_aboutsite_content` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `option_aboutsite_wechat` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `option_aboutsite_qq` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `option_aboutsite_github` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `option_aboutsite_weibo` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `option_tongji` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `option_status` int(1) NULL DEFAULT 1,
  PRIMARY KEY (`option_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of options
-- ----------------------------
INSERT INTO `options` VALUES (1, '飞鸟博客', '飞鸟尽良弓藏 狡兔死走狗烹', '飞鸟博客,一个简洁的Java博客。', '飞鸟博客,Java博客,SSM博客', '/img/timg.jpg', '博客初心', '程序人生，永不止步', '', '', '', '', NULL, 1);

-- ----------------------------
-- Table structure for page
-- ----------------------------
DROP TABLE IF EXISTS `page`;
CREATE TABLE `page`  (
  `page_id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,
  `page_key` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `page_title` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `page_content` mediumtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `page_create_time` datetime(0) NULL DEFAULT NULL,
  `page_update_time` datetime(0) NULL DEFAULT NULL,
  `page_view_count` int(10) UNSIGNED NULL DEFAULT 0,
  `page_comment_count` int(5) UNSIGNED NULL DEFAULT 0,
  `page_status` int(1) UNSIGNED NULL DEFAULT 1,
  PRIMARY KEY (`page_id`) USING BTREE,
  UNIQUE INDEX `page_key`(`page_key`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 6 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of page
-- ----------------------------
INSERT INTO `page` VALUES (1, 'map', '站点地图', NULL, NULL, NULL, 0, 0, 2);
INSERT INTO `page` VALUES (2, 'articleFile', '文章归档', NULL, NULL, NULL, 0, 0, 2);
INSERT INTO `page` VALUES (4, 'applyLink', '申请友链', NULL, NULL, NULL, 0, 0, 2);
INSERT INTO `page` VALUES (5, 'aboutSite', '关于本站', '<div class=\"entry-content\"><div class=\"single-content fontlarge\"><h2><br></h2><p>该项目是基于SSM（Spring+SpringMVC+Mybatis）的博客系统。主要涉及的包括 JSP，JSTL，EL表达式，MySQL，Druid连接池，Spring，SpringMVC，MyBatis 等。<br>通过Maven管理依赖。目前部分功能还不完善，后续会逐渐完善优化。</p><h2><br></h2></div></div>', '2019-04-20 23:40:35', '2019-04-20 14:58:12', NULL, NULL, 1);

-- ----------------------------
-- Table structure for reader
-- ----------------------------
DROP TABLE IF EXISTS `reader`;
CREATE TABLE `reader`  (
  `reader_id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,
  `reader_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `reader_pass` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `reader_email` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `reader_avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `reader_status` int(1) NULL DEFAULT NULL,
  PRIMARY KEY (`reader_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 5 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of reader
-- ----------------------------
INSERT INTO `reader` VALUES (3, '灯下黑', 'e10adc3949ba59abbe56e057f20f883e', 'twl19970606@163.com', '/img/avatar.jpg', 1);
INSERT INTO `reader` VALUES (4, '困坐南山下', 'e10adc3949ba59abbe56e057f20f883e', '1397213866@qq.com', '/img/avatar.jpg', 1);

-- ----------------------------
-- Table structure for tag
-- ----------------------------
DROP TABLE IF EXISTS `tag`;
CREATE TABLE `tag`  (
  `tag_id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,
  `tag_name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `tag_description` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`tag_id`) USING BTREE,
  UNIQUE INDEX `tag_name`(`tag_name`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 34 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tag
-- ----------------------------
INSERT INTO `tag` VALUES (1, 'HTML/CSS', NULL);
INSERT INTO `tag` VALUES (2, 'JavaScript', NULL);
INSERT INTO `tag` VALUES (3, 'Vue', NULL);
INSERT INTO `tag` VALUES (4, 'Bootstrap', NULL);
INSERT INTO `tag` VALUES (5, 'jQuery', NULL);
INSERT INTO `tag` VALUES (6, 'Java', NULL);
INSERT INTO `tag` VALUES (7, 'JavaWeb', NULL);
INSERT INTO `tag` VALUES (8, 'Jsp', NULL);
INSERT INTO `tag` VALUES (9, 'Python', NULL);
INSERT INTO `tag` VALUES (10, 'C++', NULL);
INSERT INTO `tag` VALUES (11, 'C语言', NULL);
INSERT INTO `tag` VALUES (12, 'MySQL', NULL);
INSERT INTO `tag` VALUES (13, 'Oracle', NULL);
INSERT INTO `tag` VALUES (14, 'SQL Server', NULL);
INSERT INTO `tag` VALUES (15, 'Redis', NULL);
INSERT INTO `tag` VALUES (16, '数据结构与算法', NULL);
INSERT INTO `tag` VALUES (17, '操作系统', NULL);
INSERT INTO `tag` VALUES (18, 'Windows', NULL);
INSERT INTO `tag` VALUES (19, 'Linux', NULL);
INSERT INTO `tag` VALUES (20, 'Web前端', NULL);
INSERT INTO `tag` VALUES (21, '数据库技术', NULL);
INSERT INTO `tag` VALUES (22, '计算机网络', NULL);
INSERT INTO `tag` VALUES (23, 'Http', NULL);
INSERT INTO `tag` VALUES (24, 'Https', NULL);
INSERT INTO `tag` VALUES (25, 'FTP', NULL);
INSERT INTO `tag` VALUES (26, 'IDEA', NULL);
INSERT INTO `tag` VALUES (27, 'Eclipse', NULL);
INSERT INTO `tag` VALUES (28, 'Maven', NULL);
INSERT INTO `tag` VALUES (29, 'Tomcat', NULL);
INSERT INTO `tag` VALUES (30, 'Spring', NULL);
INSERT INTO `tag` VALUES (31, 'SpringMVC', NULL);
INSERT INTO `tag` VALUES (32, 'Mybatis', NULL);
INSERT INTO `tag` VALUES (33, 'Springboot', NULL);

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user`  (
  `user_id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,
  `user_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '',
  `user_pass` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '',
  `user_nickname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '',
  `user_email` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '',
  `user_url` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '',
  `user_avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `user_last_login_ip` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `user_register_time` datetime(0) NULL DEFAULT NULL,
  `user_last_login_time` datetime(0) NULL DEFAULT NULL,
  `user_status` int(1) UNSIGNED NULL DEFAULT 1,
  PRIMARY KEY (`user_id`) USING BTREE,
  UNIQUE INDEX `user_name`(`user_name`) USING BTREE,
  UNIQUE INDEX `user_email`(`user_email`) USING BTREE
) ENGINE = MyISAM AUTO_INCREMENT = 3 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES (1, 'admin', '123456', '飞鸟', '909028627@qq.com', '', '/uploads/2019\\4/pp.jpg', '0:0:0:0:0:0:0:1', '2019-02-06 21:56:33', '2019-04-24 17:44:53', 1);

SET FOREIGN_KEY_CHECKS = 1;
